---
title: "MCA Anaylse Beläge"
author: "Sarah Pfeiffer"
date: today
format: 
    html:
        toc: true
        code-fold: false

---

## MCA Anaylse für Szenario 0 bis 3

Ziel: Wahl der besten drei Beläge nach MCA Berechnung

**Szenario 0:** "Baseline (IST-Analyse)": Simuliert die aktuellen Projektanforderungen (deir IST-Analyse). Der Fokus liegt primär auf Wirtschaftlichkeit (insb. kosten) und hoher Nutzungsqualität (insb. befahrbarkeit und barrierefreiheit). Ökologische Aspekte sind sekundär.

**Szenario 1:** "Forschungsfokus": Bildet meine zentrale Forschungsfrage (FQ) ab. Dieses Szenario sucht die Balance zwischen den beiden Hauptsäulen meiner Arbeit: dem Lebenszyklus-Fokus (H1/H2) und dem Vermeidungsprinzip (H3).

**Szenario 2:** "Radikale Vermeidung": Testet Hypothese 3 (H3) im Extrem. Es priorisiert radikal die Kriterien des Vermeidungsprinzips, also Umweltbelastung (co2, graueEnergie) und Kreislauffähigkeit (recyclingfaehigkeit, modulareErneuerbarkeit).

**Szenario 3:** "Radikaler Lebenszyklus": Testet die Hypothesen 1 und 2 (H1/H2) im Extrem. Es priorisiert radikal die Kriterien der Langlebigkeit & Wirtschaftlichkeit (insb. lebensdauer und unterhalt), um die Anzahl der Sanierungs-Eingriffe über den Zeitstrahl zu minimieren.


## Libraries laden

```{r}

library(tidyverse)
library(readr)
library(ggplot2)
library(forcats)
library(tidytext)

```

## 1. Daten Importieren

Einlesen der Rohdaten für Belaege und Gewichtung für Szenario 0 bis 3

```{r}

## 1. Daten Importieren

# Liest die Rohdaten für die Beläge ein
df_belaege_raw <- read_delim(
  "01_data_input/Belaege_tidy.csv",
  delim = ";"
)

# Liest die Gewichtungen für alle vier Szenarien ein
weights_s0_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario0.csv",
  delim = ";"
)
weights_s1_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario1.csv",
  delim = ";"
)
weights_s2_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario2.csv",
  delim = ";"
)
weights_s3_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario3.csv",
  delim = ";"
)

# --- PRÜFUNG BLOCK 1 ---

print("--- 1. Check: Spaltennamen Beläge (Sind alle Spaltennamen da?) ---")
colnames(df_belaege_raw)

print("--- 2. Check: Gewichtung S0 (Wurden Spalten getrennt?) ---")
head(weights_s0_raw)

print("--- 3. Check: Gewichtung S3 (Zur Sicherheit) ---")
head(weights_s3_raw)

```

## 2. Daten bereinigen und harmonisieren

Ziel: Daten für den Join und die MCA Berechnung vorbereiten.

```{r}

# A. Bereinigung der Rohdaten (Belaege_normiert.csv)
df_belaege <- df_belaege_raw %>%
  select(belagskategorie, option, everything()) 

# B. Bereinigung der Gewichtungen (ALLE SZENARIEN)
# Wir fügen den Roh-Dateien die Szenario-Namen hinzu
df_weights_s0 <- weights_s0_raw %>%
  mutate(szenario = "Szenario 0: Baseline (IST)")
df_weights_s1 <- weights_s1_raw %>%
  mutate(szenario = "Szenario 1: Forschungsfokus")
df_weights_s2 <- weights_s2_raw %>%
  mutate(szenario = "Szenario 2: Radikale Vermeidung")
df_weights_s3 <- weights_s3_raw %>%
  mutate(szenario = "Szenario 3: Radikaler Lebenszyklus")

# Jetzt binden wir sie zu einer finalen Gewichtungs-Tabelle zusammen
df_weights <- bind_rows(df_weights_s0, df_weights_s1, df_weights_s2, df_weights_s3) %>%

# Berechne das Gesamtgewicht (gewicht) aus den Rohspalten,
mutate(
  gewicht = group_weight * within_group_weight
) %>%
 
# umbenennen für den Join
rename(
  bewertungskategorie = criterion_id
) %>%
  
# Auswählen der Spalten, die der Rest des Skripts braucht
select(szenario, bewertungskategorie, gewicht, group_id)

print(df_weights, n = 48)

# --- PRÜFUNG BLOCK 2 ---

print("--- Check: Haben wir die richtigen Namen in den Gewichten? ---")
# Wir filtern mal nach allem was mit "kosten" zu tun hat
df_weights %>% 
  filter(grepl("kosten", bewertungskategorie, ignore.case = TRUE)) %>%
  select(bewertungskategorie) %>%
  distinct()

print("--- Check: Stichprobe der Gewichte ---")
# Zeig mir mal S0 und S3 im Vergleich für Kosten
df_weights %>% 
  filter(bewertungskategorie == "initialkosten_100a") %>%
  select(szenario, gewicht)

```

## 3. Datentransformation

Ziel: Transformation der Tabelle df_belaege von Wide-to-Long und anschliessende Verknüpfung mit der Tabelle df_weights über join

```{r}
# 3.1 Wide-to-Long
df_belaege_long <- df_belaege %>%
  pivot_longer(
    cols = where(is.numeric), 
    names_to = "bewertungskategorie", 
    values_to = "wert"
  )

# 3.2 JOIN mit Gewichtung
# WICHTIG: Wir nutzen left_join. 
# Alles was in der Gewichtungstabelle fehlt (wie 'initialkosten'), bekommt hier gewicht = NA.
df_belaege_joined <- df_belaege_long %>%
  left_join(df_weights, by = "bewertungskategorie", relationship = "many-to-many")

df_belaege_joined

# --- PRÜFUNG BLOCK 3 ---

# Wir geben kurz aus, was kein Gewicht hat zur Kontrolle
missing_weights <- df_belaege_joined %>% 
  filter(is.na(gewicht)) %>% 
  select(bewertungskategorie) %>% 
  distinct()

print("Diese Kriterien haben kein Gewicht (werden nur visualisiert):")
print(missing_weights)

print("--- Check: Hat 'initialkosten' KEIN Gewicht (NA)? ---")
df_belaege_joined %>%
  filter(bewertungskategorie == "initialkosten") %>%
  select(szenario, bewertungskategorie, gewicht) %>%
  distinct() %>%
  head(2) # Sollte NA zeigen (oder leer sein, falls S0)

print("--- Check: Hat 'initialkosten_100a' ein Gewicht? ---")
df_belaege_joined %>%
  filter(bewertungskategorie == "initialkosten_100a") %>%
  filter(szenario == "Szenario 0: Baseline (IST)") %>%
  select(szenario, bewertungskategorie, gewicht) %>%
  distinct() %>%
  head(2) # Sollte 0.1 zeigen

```

## 4. Explorative Datenanalyse

Ziel: Die Verteilung der Rohwerte pro Kriterium ansehen.
Dies zeigt, warum eine Normierung (Block 4) zwingend notwendig ist,
da die Skalen (Jahre, CHF, kg) völlig unterschiedlich sind.

```{r}

# Boxplot der Rohwerte (Scientific Style)
# Hinweis: Da die Einheiten gemischt sind, nutzen wir facet_wrap mit freien Skalen,
# damit man pro Kriterium überhaupt etwas erkennt.
plot_rohwerte <- ggplot(df_belaege_joined, aes(y = wert)) +
  geom_boxplot(fill = "grey95", width = 0.5) +
  
  # Facetten für jedes Kriterium, da unterschiedliche Einheiten (CHF vs Jahre)
  facet_wrap(~bewertungskategorie, scales = "free", ncol = 3) +
  
  labs(
    title = NULL, # Titel für Word-Beschriftung
    subtitle = NULL,
    x = NULL,
    y = "Rohwert (unterschiedliche Einheiten)"
  ) +
  
  theme_classic(base_size = 11) +
  
  theme(
    # Nur horizontale Gitterlinien im Facet sind hier wichtig (da y = wert vertikal ist)
    panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
    panel.grid.major.x = element_blank(),
    
    # Facetten-Label schön machen
    strip.background = element_rect(fill = "grey95", color = NA),
    strip.text = element_text(face = "bold", size = 9),
    
    # Achsen-Texte
    axis.text.x = element_text(size = 8, color = "black"),
    axis.text.y = element_blank(), # Keine Y-Text nötig im Boxplot ohne Kategorien
    axis.ticks.y = element_blank()
  )

print(plot_rohwerte)
ggsave("02_export/plots/check_01_rohwerte_verteilung.png", 
       plot = plot_rohwerte, width = 10, height = 8, dpi = 300)

# -------------------------------------------------------
# Lebenszyklus-Bilanz Beläge (100 Jahre)
# -------------------------------------------------------

# 1. Daten vorbereiten (Bleibt gleich)
df_plot_belaege_100a <- df_belaege %>% 
  select(
    belagskategorie, option,
    initialkosten, initialkosten_100a, unterhalt_100a, co2_100a, graueEnergie_100a
  ) %>%
  rename(belag = option, kategorie = belagskategorie) %>%
  pivot_longer(cols = where(is.numeric), names_to = "kriterium", values_to = "wert") %>%
  mutate(facet_label = case_when(
    kriterium == "initialkosten" ~ "1. Investitionskosten (pro Zyklus) [CHF/m²]",
    kriterium == "initialkosten_100a" ~ "2. Investitionskosten (100a kumuliert) [CHF/m²]",
    kriterium == "unterhalt_100a" ~ "3. Unterhaltskosten 100a [CHF/m²]",
    kriterium == "co2_100a" ~ "4. CO2-Emissionen 100a [kg CO2-eq/m²]",
    kriterium == "graueEnergie_100a" ~ "5. Graue Energie 100a [kWh/m²]" 
  )) %>%
  filter(!is.na(facet_label)) %>%
  mutate(kategorie = fct_relevel(kategorie, "Asphalt", "Pflaster", "Sickerbeläge")) %>%
  mutate(belag_sortiert = reorder(belag, wert))

# 2. Plot erstellen
plot_belaege_100a_final <- ggplot(df_plot_belaege_100a, 
       aes(x = belag_sortiert, y = wert, fill = kategorie)) + 
  geom_col(width = 0.6) + 
  
  # Facetten
  facet_wrap(~facet_label, ncol = 1, scales = "free_y") +
  
  scale_fill_manual(values = c("Asphalt" = "#084594", "Pflaster" = "#4292c6", "Sickerbeläge" = "#9ecae1")) +
  
  # Textumbruch x-Achse
  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 20)) +
  
  labs(title = NULL, x = NULL, y = "Wert", fill = "Belagskategorie") +
  
  theme_classic(base_size = 11) + 
  
  theme(
    legend.position = "bottom",
    panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
    panel.grid.major.x = element_blank(),
    
    # Schriftgrössen
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10, color = "black"),
    axis.text.y = element_text(size = 10, color = "black"),
    
    strip.background = element_rect(fill = "grey95", color = NA),
    strip.text = element_text(face = "bold", size = 11, hjust = 0),
    
    # Rand unten grosszügig lassen
    plot.margin = margin(t = 5, r = 5, b = 30, l = 5, unit = "mm") 
  )

print(plot_belaege_100a_final)

# 3. Speichern (Hochformat erzwingen)
ggsave("02_export/plots/Abb_Lebenszyklus_Bilanz_clean.png", 
       plot = plot_belaege_100a_final, 
       width = 8,   # Schmaler
       height = 20, # Extrem hoch (ca. 50 cm)
       dpi = 300)

# --- PRÜFUNG BLOCK 4 ---

print("--- Check: Haben wir alle 5 Facetten für den Plot? ---")
df_plot_belaege_100a %>%
  count(facet_label)

print("--- Check: Werte-Vergleich am Beispiel 'Recyclingasphalt' ---")
# Wir schauen uns einen Belag an, um zu sehen, ob Initial < 100a ist
df_plot_belaege_100a %>%
  filter(belag == "Recyclingasphalt") %>% # Oder ein anderer Name, falls dieser nicht existiert
  select(facet_label, wert) %>%
  arrange(facet_label)

```

## 5. MCA - Normalisierung

Ziel: 
-Normalisierung: Die Wert-Spalte (Jahre, CHF, etc.) muss auf eine einheitliche Skala (0-1) gebracht werden
-Wie gut ist der entsprechende Belag im entsprechenden Kriterium im Vergleich zu allen anderen Belägen? (Min-Max-Skalierung)

```{r}

# 5.1 Definieren: Wo ist "weniger" besser?
kriterien_lower_is_better <- c(
  "initialkosten", 
  "initialkosten_100a", 
  "unterhalt_100a", 
  "co2_100a", 
  "graueEnergie_100a",
  "oberflaechentemperatur" 
)

# 5.2 Min-Max-Skalierung
# WICHTIG: Hier NICHT nach Gewicht filtern, sonst verschwinden die Initialkosten!
df_belaege_normalized <- df_belaege_joined %>%
  filter(!is.na(wert)) %>%  # Nur Zeilen ohne Werte löschen
  group_by(bewertungskategorie) %>%
  mutate(
    min_wert = min(wert, na.rm = TRUE),
    max_wert = max(wert, na.rm = TRUE),
    score_normiert = case_when(
      (max_wert - min_wert) == 0 ~ 1,
      !(bewertungskategorie %in% kriterien_lower_is_better) ~ (wert - min_wert) / (max_wert - min_wert),
      bewertungskategorie %in% kriterien_lower_is_better ~ 1 - ((wert - min_wert) / (max_wert - min_wert))
    )
  ) %>%
  ungroup()

# --- PRÜFUNG BLOCK 5 ---

print("--- Check: Sind alle Kriterien da (auch die ohne Gewicht)? ---")
df_min_max_check <- df_belaege_normalized %>%
  select(bewertungskategorie, min_wert, max_wert) %>%
  distinct()

print(df_min_max_check)

print("--- Check: Haben 'initialkosten' einen Score bekommen? ---")
# Wir testen eine Zeile stichprobenartig
df_belaege_normalized %>%
  filter(bewertungskategorie == "initialkosten") %>%
  select(option, wert, score_normiert) %>%
  head(3)

# Prüfen, ob der Join geklappt hat (Gewicht da?):
print("--- Check Gewicht für Kosten ---")
df_belaege_normalized %>%
  filter(bewertungskategorie %in% c("initialkosten", "initialkosten_100a")) %>%
  select(szenario, bewertungskategorie, gewicht) %>%
  distinct() %>%
  print()
```

## 6. Explorative Datenanalyse

Ziel: Überprüfen, ob die Min-Max-Skalierung (Block 5.2) funktioniert hat.

```{r}
# Boxplot der normierten Scores (Scientific Style)
plot_normiert <- ggplot(df_belaege_normalized, aes(x = bewertungskategorie, y = score_normiert)) +
  geom_boxplot(fill = "grey90", width = 0.6, outlier.colour = "black", outlier.size = 1) +
  
  coord_flip() +
  
  # Fixe Skala 0-1
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0.05)) +
  
  labs(
    title = NULL,
    subtitle = NULL,
    x = NULL, # Kriterien-Namen stehen an der Achse
    y = "Normierter Score (0 = schlecht, 1 = ideal)"
  ) +
  
  theme_classic(base_size = 11) +
  
  theme(
    # Gitterlinien: Vertikal wichtig (um 0.5 etc. zu sehen), Horizontal weg
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    panel.grid.major.y = element_blank(),
    
    # Achsen-Texte
    axis.text.y = element_text(color = "black", size = 10), # Kriterien-Namen
    axis.text.x = element_text(color = "black", size = 10)  # Zahlen 0-1
  )

print(plot_normiert)
ggsave("02_export/plots/check_02_normierte_scores_belaege.png", 
       plot = plot_normiert, width = 10, height = 7, dpi = 300)

# --- PRÜFUNG BLOCK 6 ---

print("--- Check: Liegen alle Scores zwischen 0 und 1? ---")
summary(df_belaege_normalized$score_normiert)
# Min sollte >= 0.00 sein, Max <= 1.00

print("--- Check: Sind 'initialkosten' im Boxplot-Datensatz enthalten? ---")
# Wir zählen, wie viele Datenpunkte wir pro Kategorie haben
df_belaege_normalized %>%
  filter(bewertungskategorie %in% c("initialkosten", "initialkosten_100a")) %>%
  count(bewertungskategorie)
```

## 7. MCA Berechnung

Ziel: Berechnung der besten geeigneten Beläge auf Basis Kriterienbewertung (score_normiert * gewicht)

```{r}

# 7.1 Berechnung Score pro Kriterium
df_mca_calculated <- df_belaege_normalized %>%
  # HIER filtern wir jetzt alles raus, was kein Gewicht hat (z.B. reine Initialkosten)
  filter(!is.na(gewicht)) %>% 
  mutate(MCA_score_kriterium = score_normiert * gewicht)

# 7.2 Aggregation pro Szenario
df_mca_total <- df_mca_calculated %>%
  group_by(szenario, belagskategorie, option) %>%
  summarise(MCA_gesamtscore = sum(MCA_score_kriterium, na.rm = TRUE), .groups = 'drop') %>%
  arrange(szenario, desc(MCA_gesamtscore)) 

print("--- MCA Gesamtergebnis ---")
print(df_mca_total, n = 40)

# 7.3 - Auswahl der "Top 3 Sieger"
# Ziel: Für jedes der 4 Szenarien die Top 3 Beläge aus dem
# Gesamtranking auswählen (unabhängig von der Kategorie).

N_BELAEGE_AUSWAEHLEN <- 3

df_sieger_belaege <- df_mca_total %>%
  group_by(szenario) %>%
  # Wählt die N besten Beläge innerhalb jedes Szenarios aus
  slice_max(MCA_gesamtscore, n = N_BELAEGE_AUSWAEHLEN) %>%
  ungroup() %>%
  # Ordnen für bessere Lesbarkeit
  arrange(szenario, desc(MCA_gesamtscore))

# Anzeigen der 12 Sieger-Optionen (4 Szenarien * 3 Beläge)
print(paste("--- Top", N_BELAEGE_AUSWAEHLEN, "Beläge pro Szenario (für Zeitstrahl-Analyse) ---"))
print(df_sieger_belaege, n = 12)

# Diese Auswahl auch exportieren
write_csv2(
  df_sieger_belaege,
  file = "02_export/tables/mca_top3_belaege_pro_szenario.csv"
)

# --- PRÜFUNG BLOCK 7 ---

print("--- Check: Enthält die Berechnung noch Zeilen ohne Gewicht? ---")
# Sollte 0 Zeilen ergeben
df_mca_calculated %>% filter(is.na(gewicht)) %>% count()

print("--- Check: Plausibilität Ergebnisse (S0 Baseline) ---")
# Zeig mir die Top 3 von Szenario 0
df_sieger_belaege %>% 
  filter(szenario == "Szenario 0: Baseline (IST)") %>%
  select(option, MCA_gesamtscore)

```

## 8. Darstellung

Ziel: visualisierung der Ergebnisse 

### 8.1 Plot: Szenario 0 - Baseline (IST)

```{r}
#| label: fig-mca-plots-belaege-s0
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Datenaufbereitung für Stacked Plot (einmalig & aufgehübscht) ---
df_mca_groups_belaege_plot <- df_mca_calculated %>%
  group_by(szenario, belagskategorie, option, group_id) %>%
  summarise(gruppen_score = sum(MCA_score_kriterium, na.rm = TRUE), .groups = 'drop') %>%
  left_join(df_mca_total, by = c("szenario", "belagskategorie", "option")) %>%
  mutate(group_label_clean = case_when(
    group_id == "langlebigkeit_wirtschaftlichkeit" ~ "Langlebigkeit & Wirtschaftlichkeit",
    group_id == "multifunktionale_nutzungsqualitaet" ~ "Multifunktionale Nutzungsqualität",
    group_id == "umweltbelastung" ~ "Umweltbelastung",
    group_id == "kreislauffaehigkeit" ~ "Kreislauffähigkeit",
    TRUE ~ group_id
  ))
# ----------------------------------------------------

# --- Farb-Definitionen (Wissenschaftlich / Blau-Schema) ---
# 1. Farben für Kategorien (Konsistent mit Block 4)
colors_kategorie <- c("Asphalt" = "#084594", 
                      "Pflaster" = "#4292c6", 
                      "Sickerbeläge" = "#9ecae1")

# 2. Farben für Kriterien-Gruppen (Abgestufte Blautöne/Grau)
colors_gruppen <- c(
  "Langlebigkeit & Wirtschaftlichkeit" = "#08306b", # Sehr dunkelblau (Basis)
  "Multifunktionale Nutzungsqualität" = "#2171b5",  # Mittelblau
  "Umweltbelastung" = "#6baed6",                    # Hellblau
  "Kreislauffähigkeit" = "#c6dbef"                  # Sehr hellblau/Grau
)
# ----------------------------------------------------


# --- Plot 1: Ranking (Szenario 0) ---
data_s0 <- df_mca_total %>% filter(szenario == "Szenario 0: Baseline (IST)")

plot_s0_rank <- ggplot(data_s0,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = belagskategorie)) + 
  geom_col(width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) + 
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  # HIER: Deine Blautöne anwenden!
  scale_fill_manual(values = colors_kategorie) +
  
  labs(
    title = NULL, 
    x = "MCA Score (0-1)", 
    y = NULL, 
    fill = "Kategorie"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  )

print(plot_s0_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s0_belaege.png",
       plot = plot_s0_rank, width = 10, height = 7, dpi = 300)


# --- Plot 2: Stacked Detail (Szenario 0) ---
data_s0_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 0: Baseline (IST)")

plot_s0_stack <- ggplot(data_s0_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = group_label_clean)) + 
  geom_col(position = "stack", width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  # HIER: Die neuen Gruppen-Farben anwenden!
  scale_fill_manual(values = colors_gruppen) +
  
  labs(
    title = NULL, 
    x = "Beitrag zum Score", 
    y = NULL, 
    fill = "Kriteriengruppe"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 9), 
    legend.title = element_text(face = "bold"),
    legend.box = "vertical",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  ) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))

print(plot_s0_stack)
ggsave("02_export/plots/mca_detail_gruppen_s0_belaege.png",
       plot = plot_s0_stack, width = 10, height = 7, dpi = 300)

```

### 8.2 Plot: Szenario 1 - Forschungsfokus

```{r}
#| label: fig-mca-plots-belaege-s1
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Plot 1: Ranking (Szenario 1) ---
data_s1 <- df_mca_total %>% filter(szenario == "Szenario 1: Forschungsfokus")

plot_s1_rank <- ggplot(data_s1,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = belagskategorie)) + 
  geom_col(width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) + 
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  # Farben wiederverwenden
  scale_fill_manual(values = colors_kategorie) +
  
  labs(
    title = NULL, 
    x = "MCA Score (0-1)", 
    y = NULL, 
    fill = "Kategorie"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  )

print(plot_s1_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s1_belaege.png",
       plot = plot_s1_rank, width = 10, height = 7, dpi = 300)


# --- Plot 2: Stacked Detail (Szenario 1) ---
data_s1_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 1: Forschungsfokus")

plot_s1_stack <- ggplot(data_s1_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = group_label_clean)) + 
  geom_col(position = "stack", width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  # Farben wiederverwenden
  scale_fill_manual(values = colors_gruppen) +
  
  labs(
    title = NULL, 
    x = "Beitrag zum Score", 
    y = NULL, 
    fill = "Kriteriengruppe"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 9), 
    legend.title = element_text(face = "bold"),
    legend.box = "vertical",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  ) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))

print(plot_s1_stack)
ggsave("02_export/plots/mca_detail_gruppen_s1_belaege.png",
       plot = plot_s1_stack, width = 10, height = 7, dpi = 300)
```

### 8.3 Plot: Szenario 2 - Radikale Vermeidung

```{r}
#| label: fig-mca-plots-belaege-s2
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Plot 1: Ranking (Szenario 2) ---
data_s2 <- df_mca_total %>% filter(szenario == "Szenario 2: Radikale Vermeidung")

plot_s2_rank <- ggplot(data_s2,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = belagskategorie)) + 
  geom_col(width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) + 
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  scale_fill_manual(values = colors_kategorie) +
  
  labs(
    title = NULL, 
    x = "MCA Score (0-1)", 
    y = NULL, 
    fill = "Kategorie"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  )

print(plot_s2_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s2_belaege.png",
       plot = plot_s2_rank, width = 10, height = 7, dpi = 300)


# --- Plot 2: Stacked Detail (Szenario 2) ---
data_s2_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 2: Radikale Vermeidung")

plot_s2_stack <- ggplot(data_s2_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = group_label_clean)) + 
  geom_col(position = "stack", width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  scale_fill_manual(values = colors_gruppen) +
  
  labs(
    title = NULL, 
    x = "Beitrag zum Score", 
    y = NULL, 
    fill = "Kriteriengruppe"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 9), 
    legend.title = element_text(face = "bold"),
    legend.box = "vertical",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  ) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))

print(plot_s2_stack)
ggsave("02_export/plots/mca_detail_gruppen_s2_belaege.png",
       plot = plot_s2_stack, width = 10, height = 7, dpi = 300)

```

### 8.4 Plot: Szenario 3 - Radikaler Lebenszyklus

```{r}
#| label: fig-mca-plots-belaege-s3
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Plot 1: Ranking (Szenario 3) ---
data_s3 <- df_mca_total %>% filter(szenario == "Szenario 3: Radikaler Lebenszyklus")

plot_s3_rank <- ggplot(data_s3,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = belagskategorie)) + 
  geom_col(width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) + 
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  scale_fill_manual(values = colors_kategorie) +
  
  labs(
    title = NULL, 
    x = "MCA Score (0-1)", 
    y = NULL, 
    fill = "Kategorie"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  )

print(plot_s3_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s3_belaege.png",
       plot = plot_s3_rank, width = 10, height = 7, dpi = 300)


# --- Plot 2: Stacked Detail (Szenario 3) ---
data_s3_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 3: Radikaler Lebenszyklus")

plot_s3_stack <- ggplot(data_s3_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), 
           fill = group_label_clean)) + 
  geom_col(position = "stack", width = 0.7) +
  
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0.05)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 40)) +
  
  scale_fill_manual(values = colors_gruppen) +
  
  labs(
    title = NULL, 
    x = "Beitrag zum Score", 
    y = NULL, 
    fill = "Kriteriengruppe"
  ) +
  theme_classic(base_size = 11) + 
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 9), 
    legend.title = element_text(face = "bold"),
    legend.box = "vertical",
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", linewidth = 0.2),
    axis.text = element_text(color = "black"),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "mm")
  ) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))

print(plot_s3_stack)
ggsave("02_export/plots/mca_detail_gruppen_s3_belaege.png",
       plot = plot_s3_stack, width = 10, height = 7, dpi = 300)
```


## 9. Ergebnisstabellen exportieren

```{r}

# 1. Speichern der finalen MCA-Rangliste (alle 40 Zeilen)
write_csv2(
  df_mca_total,
  file = "02_export/tables/mca_rangliste_alle_szenarien.csv"
)

# 2. Speichern der kompletten Berechnungs-Details (alle 360+ Zeilen)
write_csv2(
  df_mca_calculated,
  file = "02_export/tables/mca_details_berechnung_alle_szenarien.csv"
)

# --- PRÜFUNG BLOCK 9 ---

print("--- Check 1: Ist die Rangliste vollständig? (Erwartet: 40 Zeilen) ---")
# 10 Beläge * 4 Szenarien = 40 Zeilen
nrow(df_mca_total)

print("--- Check 2: Sind die Details vollständig? ---")
# Sollte > 300 sein (40 Zeilen * ca. 9-11 Kriterien pro Szenario)
nrow(df_mca_calculated)

print("--- Check 3: Existiert der Ordner? (Optional) ---")
# Falls der Ordner nicht existiert, würde write_csv2 einen Fehler werfen.
dir.exists("02_export/tables")
 
```

