---
title: "MCA Anaylse Beläge"
author: "Sarah Pfeiffer"
date: today
format: 
    html:
        toc: true
        code-fold: false

---

## MCA Anaylse für Szenario 0 bis 3

Ziel: Wahl der besten drei Beläge nach MCA Berechnung

**Szenario 0:** "Baseline (IST-Analyse)": Simuliert die aktuellen Projektanforderungen (deir IST-Analyse). Der Fokus liegt primär auf Wirtschaftlichkeit (insb. kosten) und hoher Nutzungsqualität (insb. befahrbarkeit und barrierefreiheit). Ökologische Aspekte sind sekundär.

**Szenario 1:** "Forschungsfokus": Bildet meine zentrale Forschungsfrage (FQ) ab. Dieses Szenario sucht die Balance zwischen den beiden Hauptsäulen meiner Arbeit: dem Lebenszyklus-Fokus (H1/H2) und dem Vermeidungsprinzip (H3).

**Szenario 2:** "Radikale Vermeidung": Testet Hypothese 3 (H3) im Extrem. Es priorisiert radikal die Kriterien des Vermeidungsprinzips, also Umweltbelastung (co2, graueEnergie) und Kreislauffähigkeit (recyclingfaehigkeit, modulareErneuerbarkeit).

**Szenario 3:** "Radikaler Lebenszyklus": Testet die Hypothesen 1 und 2 (H1/H2) im Extrem. Es priorisiert radikal die Kriterien der Langlebigkeit & Wirtschaftlichkeit (insb. lebensdauer und unterhalt), um die Anzahl der Sanierungs-Eingriffe über den Zeitstrahl zu minimieren.


## Libraries laden

```{r}

library(tidyverse)
library(readr)
library(ggplot2)
library(forcats)
library(tidytext)

```

## 1. Daten Importieren

Einlesen der Rohdaten für Belaege und Gewichtung für Szenario 0 bis 3

```{r}

## 1. Daten Importieren

# Liest die Rohdaten für die Beläge ein
df_belaege_raw <- read_delim(
  "01_data_input/Belaege_tidy.csv",
  delim = ";"
)

# Liest die Gewichtungen für alle vier Szenarien ein
weights_s0_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario0.csv",
  delim = ";"
)
weights_s1_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario1.csv",
  delim = ";"
)
weights_s2_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario2.csv",
  delim = ";"
)
weights_s3_raw <- read_delim(
  "01_data_input/Belaege_Gewichtung_Szenario3.csv",
  delim = ";"
)
```

## 2. Daten bereinigen und harmonisieren

Ziel: Daten für den Join und die MCA Berechnung vorbereiten.

```{r}

# A. Bereinigung der Rohdaten (Belaege_normiert.csv)
df_belaege <- df_belaege_raw %>%
  select(belagskategorie, option, everything()) 

# B. Bereinigung der Gewichtungen (ALLE SZENARIEN)
# Wir fügen den Roh-Dateien die Szenario-Namen hinzu
df_weights_s0 <- weights_s0_raw %>%
  mutate(szenario = "Szenario 0: Baseline (IST)")
df_weights_s1 <- weights_s1_raw %>%
  mutate(szenario = "Szenario 1: Forschungsfokus")
df_weights_s2 <- weights_s2_raw %>%
  mutate(szenario = "Szenario 2: Radikale Vermeidung")
df_weights_s3 <- weights_s3_raw %>%
  mutate(szenario = "Szenario 3: Radikaler Lebenszyklus")

# Jetzt binden wir sie zu einer finalen Gewichtungs-Tabelle zusammen
df_weights <- bind_rows(df_weights_s0, df_weights_s1, df_weights_s2, df_weights_s3) %>%

# Berechne das Gesamtgewicht (gewicht) aus den Rohspalten,
mutate(
  gewicht = group_weight * within_group_weight
) %>%
 
# umbenennen für den Join
rename(
  bewertungskategorie = criterion_id
) %>%
  
# Auswählen der Spalten, die der Rest des Skripts braucht
select(szenario, bewertungskategorie, gewicht, group_id)

print(df_weights, n = 48)

```

## 3. Datentransformation

Ziel: Transformation der Tabelle df_belaege von Wide-to-Long und anschliessende Verknüpfung mit der Tabelle df_weights über join

```{r}
# 3.1 Wide-to-Long: Transformation der Rohdaten
# Ziel: Die Kriterien-Spalten (z.B. lebensdauer, kosten) in Zeilen umwandeln,
# damit sie mit der Gewichtungstabelle verknüpft werden kann.

df_belaege_long <- df_belaege %>%
  pivot_longer(
    # Nimm alle Spalten von 'lebensdauer' bis 'modulareErneuerbarkeit'
    # und die vier '_100a'-Spalten.
    cols = c(lebensdauer:modulareErneuerbarkeit, 
             kosten_100a, unterhalt_100a, co2_100a, graueEnergie_100a), 
    # ---------------------------
    names_to = "bewertungskategorie", 
    values_to = "wert"
  )

# 3.2 JOIN: Verknüpfung der Long-Tabelle mit der Gewichtungstabelle
# Ziel: Jede Kriteriums-Zeile (z.B. "lebensdauer") mit ihrem 
# entsprechenden Gewicht (z.B. 0.1) anreichern.

df_belaege_joined <- df_belaege_long %>%
  # Verknüpft die 'df_belaege_long' (linke Tabelle) mit 'df_weights' (rechte Tabelle).
  # Die Verknüpfung ("der Schlüssel") ist die Spalte "bewertungskategorie",
  # die jetzt in beiden Tabellen identisch heisst.
  left_join(df_weights, by = "bewertungskategorie",# Diese Zeile sagt R, dass wir den Many-to-Many-Join erwarten
            relationship = "many-to-many" 
  )


```

## 4. Explorative Datenanalyse

Ziel: Die Verteilung der Rohwerte pro Kriterium ansehen.
Dies zeigt, warum eine Normierung (Block 4) zwingend notwendig ist,
da die Skalen (Jahre, CHF, kg) völlig unterschiedlich sind.

```{r}

# Boxplot der Rohwerte
plot_rohwerte <- ggplot(df_belaege_joined, aes(x = bewertungskategorie, y = wert)) +
  geom_boxplot() +
  # coord_flip() dreht die Achsen, damit die Namen lesbar sind
  coord_flip() +
  labs(
    title = "Verteilung der Rohwerte (vor Normierung)",
    subtitle = "Zeigt die unterschiedlichen Skalen (Einheiten) der Kriterien",
    x = "Kriterium",
    y = "Wert (gemischte Einheiten)"
  ) +
  theme_minimal()

print(plot_rohwerte)
ggsave("02_export/plots/check_01_rohwerte_verteilung.png", plot = plot_rohwerte, width = 10, height = 7)

```

## 5. MCA - Normalisierung

Ziel: 
-Normalisierung: Die Wert-Spalte (Jahre, CHF, etc.) muss auf eine einheitliche Skala (0-1) gebracht werden
-Wie gut ist der entsprechende Belag im entsprechenden Kriterium im Vergleich zu allen anderen Belägen? (Min-Max-Skalierung)

```{r}

# 5.1 Definieren, welche Kriterien 'schlechter' sind, wenn sie 'höher' sind

kriterien_lower_is_better <- c(
  "kosten_100a", 
  "unterhalt_100a", 
  "co2_100a", 
  "graueEnergie_100a",
  "oberflaechentemperatur" 
)

# 5.2 Min-Max-Skalierung (Normierung)
# Aufgeteilt in zwei Schritte für die Überprüfung

# Schritt 5.2a: Min/Max-Werte berechnen und in einer Zwischentabelle speichern
df_belaege_with_minmax <- df_belaege_joined %>%
  filter(!is.na(wert)) %>% # NAs im Wert ignorieren
  filter(!is.na(gewicht)) %>% # NAs im Gewicht ignorieren (wichtig!)
  group_by(bewertungskategorie) %>%
  # 1. Min und Max für jedes Kriterium finden
  mutate(
    min_wert = min(wert, na.rm = TRUE),
    max_wert = max(wert, na.rm = TRUE)
  ) %>%
  ungroup()

# Überprüfung der Min/Max-Werte: Erstellt eine kleine, saubere Tabelle, die nur die Min/Max-Werte zeigt
df_min_max_summary <- df_belaege_with_minmax %>%
  select(bewertungskategorie, min_wert, max_wert) %>%
  distinct() # Zeigt jede Kategorie nur einmal an

print("--- Min/Max-Werte pro Kriterium (für Normierung) ---")
print(df_min_max_summary)
# --------------------------------------------------------


# Schritt 5.2b: Skalierung auf 0-1 berechnen
# Wir nehmen die Tabelle aus 5.2a und rechnen weiter
df_belaege_normalized <- df_belaege_with_minmax %>%
  # 2. Skalieren auf 0-1
  mutate(
    # Sonderfall: Wenn Min und Max gleich sind (nur ein Wert), setze Score auf 1
    score_normiert = case_when(
      (max_wert - min_wert) == 0 ~ 1,
      
      # Normale Skalierung (higher is better), ! bedeutet NICHT in kriterien_lower_is_better Liste enthalten
      !(bewertungskategorie %in% kriterien_lower_is_better) ~ (wert - min_wert) / (max_wert - min_wert),
      
      # Invertierte Skalierung (lower is better)
      bewertungskategorie %in% kriterien_lower_is_better ~ 1 - ((wert - min_wert) / (max_wert - min_wert))
    )
  )

```

## 6. Explorative Datenanalyse

Ziel: Überprüfen, ob die Min-Max-Skalierung (Block 5.2) funktioniert hat.

```{r}
# Boxplot der normierten Scores
plot_normiert <- ggplot(df_belaege_normalized, aes(x = bewertungskategorie, y = score_normiert)) +
  geom_boxplot() +
  coord_flip() +
  # Setzt die Y-Achse fix auf 0 bis 1
  scale_y_continuous(limits = c(0, 1)) +
  labs(
    title = "Verteilung der normierten Scores (nach Normierung)",
    subtitle = "Qualitätskontrolle: Alle Kriterien sollten jetzt auf 0-1 skaliert sein.",
    x = "Kriterium",
    y = "Normierter Score (0-1)"
  ) +
  theme_minimal()

print(plot_normiert)
ggsave("02_export/plots/check_02_normierte_scores.png", plot = plot_normiert, width = 10, height = 7)
```

## 7. MCA Berechnung

Ziel: Berechnung der besten geeigneten Beläge auf Basis Kriterienbewertung (score_normiert * gewicht)

```{r}

# 7.1 Berechnung des gewichteten Scores
# (Keine Änderung hier, 'gewicht' ist jetzt pro Szenario unterschiedlich)
df_mca_calculated <- df_belaege_normalized %>%
  mutate(
    MCA_score_kriterium = score_normiert * gewicht
  )

# 7.2 Aggregation 
# Wir gruppieren jetzt AUCH nach 'szenario'
df_mca_total <- df_mca_calculated %>%
  group_by(szenario, belagskategorie, option) %>% # <-- 'szenario' hinzugefügt
  summarise(
    MCA_gesamtscore = sum(MCA_score_kriterium, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # Wir sortieren erst nach Szenario, dann nach Score
  arrange(szenario, desc(MCA_gesamtscore)) 

# Anzeigen der Ergebnisse (jetzt 40 Zeilen, 10 pro Szenario)
print("--- MCA Gesamtergebnis (sortiert) ---")
print(df_mca_total, n = 40) # n=40, um alle Ergebnisse zu sehen

# 7.3 - Auswahl der "Top 3 Sieger"
# Ziel: Für jedes der 4 Szenarien die Top 3 Beläge aus dem
# Gesamtranking auswählen (unabhängig von der Kategorie).

N_BELAEGE_AUSWAEHLEN <- 3

df_sieger_belaege <- df_mca_total %>%
  group_by(szenario) %>%
  # Wählt die N besten Beläge innerhalb jedes Szenarios aus
  slice_max(MCA_gesamtscore, n = N_BELAEGE_AUSWAEHLEN) %>%
  ungroup() %>%
  # Ordnen für bessere Lesbarkeit
  arrange(szenario, desc(MCA_gesamtscore))

# Anzeigen der 12 Sieger-Optionen (4 Szenarien * 3 Beläge)
print(paste("--- Top", N_BELAEGE_AUSWAEHLEN, "Beläge pro Szenario (für Zeitstrahl-Analyse) ---"))
print(df_sieger_belaege, n = 12)

# Diese Auswahl auch exportieren
write_csv2(
  df_sieger_belaege,
  file = "02_export/tables/mca_top3_belaege_pro_szenario.csv"
)

```

## 8. Darstellung

Ziel: visualisierung der Ergebnisse 

### 8.1 Plot: Szenario 0 - Baseline (IST)

```{r}
#| label: fig-mca-plots-belaege-s0
#| fig.width: 13 # Breite wie bei Bäumen
#| fig.height: 8  # Höhe angepasst (weniger Optionen als Bäume)
#| out.width: "95%"
#| dpi: 300

# --- Datenaufbereitung für Stacked Plot (einmalig) ---
df_mca_groups_belaege_plot <- df_mca_calculated %>%
  # Ggf. hier auf Kleinbuchstaben umbenennen, falls nötig (siehe Block 7)
  # rename(belagskategorie = Belagskategorie, option = Option) %>%
  group_by(szenario, belagskategorie, option, group_id) %>%
  summarise(gruppen_score = sum(MCA_score_kriterium, na.rm = TRUE), .groups = 'drop') %>%
  left_join(df_mca_total, by = c("szenario", "belagskategorie", "option"))
# ----------------------------------------------------

# --- Plot 1: Ranking ---
data_s0 <- df_mca_total %>% filter(szenario == "Szenario 0: Baseline (IST)")

plot_s0_rank <- ggplot(data_s0,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = belagskategorie)) + # lc
  geom_col() +
  labs(
    title = "MCA Ergebnis Beläge: Szenario 0 - Baseline (IST)",
    subtitle = "Ranking (Höher = Besser)",
    x = "MCA Gesamtscore", y = "Belagsoption", fill = "Belagskategorie" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8)) # Etwas grösser als bei Bäumen?

print(plot_s0_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s0_belaege.png",
       plot = plot_s0_rank, width = 13, height = 8, units = "in", dpi = 300)

# --- Plot 2: Stacked Detail ---
data_s0_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 0: Baseline (IST)")

plot_s0_stack <- ggplot(data_s0_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = group_id)) +
  geom_col(position = "stack") +
  labs(
    title = "MCA Detail Beläge: Szenario 0 - Baseline (IST)",
    subtitle = "Zusammensetzung des Scores",
    x = "MCA Score (Anteil)", y = "Belagsoption", fill = "Kriteriengruppe" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s0_stack)
ggsave("02_export/plots/mca_detail_gruppen_s0_belaege.png",
       plot = plot_s0_stack, width = 13, height = 8, units = "in", dpi = 300)


```

### 8.2 Plot: Szenario 1 - Forschungsfokus

```{r}
#| label: fig-mca-plots-belaege-s1
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Plot 1: Ranking ---
data_s1 <- df_mca_total %>% filter(szenario == "Szenario 1: Forschungsfokus")

plot_s1_rank <- ggplot(data_s1,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = belagskategorie)) + # lc
  geom_col() +
  labs(
    title = "MCA Ergebnis Beläge: Szenario 1 - Forschungsfokus",
    subtitle = "Ranking (Höher = Besser)",
    x = "MCA Gesamtscore", y = "Belagsoption", fill = "Belagskategorie" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s1_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s1_belaege.png",
       plot = plot_s1_rank, width = 13, height = 8, units = "in", dpi = 300)

# --- Plot 2: Stacked Detail ---
data_s1_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 1: Forschungsfokus")

plot_s1_stack <- ggplot(data_s1_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = group_id)) +
  geom_col(position = "stack") +
  labs(
    title = "MCA Detail Beläge: Szenario 1 - Forschungsfokus",
    subtitle = "Zusammensetzung des Scores",
    x = "MCA Score (Anteil)", y = "Belagsoption", fill = "Kriteriengruppe" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s1_stack)
ggsave("02_export/plots/mca_detail_gruppen_s1_belaege.png",
       plot = plot_s1_stack, width = 13, height = 8, units = "in", dpi = 300)
```

### 8.3 Plot: Szenario 2 - Radikale Vermeidung

```{r}
#| label: fig-mca-plots-belaege-s2
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Plot 1: Ranking ---
data_s2 <- df_mca_total %>% filter(szenario == "Szenario 2: Radikale Vermeidung")

plot_s2_rank <- ggplot(data_s2,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = belagskategorie)) + # lc
  geom_col() +
  labs(
    title = "MCA Ergebnis Beläge: Szenario 2 - Radikale Vermeidung",
    subtitle = "Ranking (Höher = Besser)",
    x = "MCA Gesamtscore", y = "Belagsoption", fill = "Belagskategorie" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s2_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s2_belaege.png",
       plot = plot_s2_rank, width = 13, height = 8, units = "in", dpi = 300)

# --- Plot 2: Stacked Detail ---
data_s2_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 2: Radikale Vermeidung")

plot_s2_stack <- ggplot(data_s2_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = group_id)) +
  geom_col(position = "stack") +
  labs(
    title = "MCA Detail Beläge: Szenario 2 - Radikale Vermeidung",
    subtitle = "Zusammensetzung des Scores",
    x = "MCA Score (Anteil)", y = "Belagsoption", fill = "Kriteriengruppe" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s2_stack)
ggsave("02_export/plots/mca_detail_gruppen_s2_belaege.png",
       plot = plot_s2_stack, width = 13, height = 8, units = "in", dpi = 300)



```

### 8.4 Plot: Szenario 3 - Radikaler Lebenszyklus

```{r}
#| label: fig-mca-plots-belaege-s3
#| fig.width: 13
#| fig.height: 8
#| out.width: "95%"
#| dpi: 300

# --- Plot 1: Ranking ---
data_s3 <- df_mca_total %>% filter(szenario == "Szenario 3: Radikaler Lebenszyklus")

plot_s3_rank <- ggplot(data_s3,
       aes(x = MCA_gesamtscore,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = belagskategorie)) + # lc
  geom_col() +
  labs(
    title = "MCA Ergebnis Beläge: Szenario 3 - Radikaler Lebenszyklus",
    subtitle = "Ranking (Höher = Besser)",
    x = "MCA Gesamtscore", y = "Belagsoption", fill = "Belagskategorie" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s3_rank)
ggsave("02_export/plots/mca_gesamtergebnis_s3_belaege.png",
       plot = plot_s3_rank, width = 13, height = 8, units = "in", dpi = 300)

# --- Plot 2: Stacked Detail ---
data_s3_groups <- df_mca_groups_belaege_plot %>% filter(szenario == "Szenario 3: Radikaler Lebenszyklus")

plot_s3_stack <- ggplot(data_s3_groups,
       aes(x = gruppen_score,
           y = fct_reorder(option, MCA_gesamtscore), # lc
           fill = group_id)) +
  geom_col(position = "stack") +
  labs(
    title = "MCA Detail Beläge: Szenario 3 - Radikaler Lebenszyklus",
    subtitle = "Zusammensetzung des Scores",
    x = "MCA Score (Anteil)", y = "Belagsoption", fill = "Kriteriengruppe" # lc
  ) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.y = element_text(size = 8))

print(plot_s3_stack)
ggsave("02_export/plots/mca_detail_gruppen_s3_belaege.png",
       plot = plot_s3_stack, width = 13, height = 8, units = "in", dpi = 300)
```


## 9. Ergebnisstabellen exportieren

```{r}

# 1. Speichern der finalen MCA-Rangliste (alle 30 Zeilen)
write_csv2(
  df_mca_total,
  file = "02_export/tables/mca_rangliste_alle_szenarien.csv"
)

# 2. Speichern der kompletten Berechnungs-Details (alle 360+ Zeilen)
write_csv2(
  df_mca_calculated,
  file = "02_export/tables/mca_details_berechnung_alle_szenarien.csv"
)

```

