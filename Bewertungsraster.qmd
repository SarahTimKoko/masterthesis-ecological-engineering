---
title: "Bewertungsraster"
format: html
editor: visual
---




```{r}
# ============================================================
# Viererfeld – Multi-Kriterien-Bewertung (Beläge, Leitungen, Bäume)
# ============================================================

# Pakete -----------------------------------------------------
suppressPackageStartupMessages({
  library(readxl)
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(ggplot2)
  library(writexl)
  library(purrr)
  library(forcats)
})

# ------------------------------------------------------------
# 1) Pfade / Einstellungen
# ------------------------------------------------------------
input_file  <- "Viererfeld_Bewertung_MASTER.xlsx"   # <— ggf. Pfad anpassen
output_xlsx <- "Viererfeld_Bewertung_Ergebnisse.xlsx"
output_dir  <- "export"
if (!dir.exists(output_dir)) dir.create(output_dir)

# ------------------------------------------------------------
# 2) Daten einlesen
# ------------------------------------------------------------
read_or_stop <- function(path, sheet) {
  if (!file.exists(path)) stop(paste0("Datei nicht gefunden: ", path))
  readxl::read_excel(path, sheet = sheet)
}

raw_belaege   <- read_or_stop(input_file, "Components_Belaege")
raw_leitungen <- read_or_stop(input_file, "Components_Leitungen")
raw_baeume    <- read_or_stop(input_file, "Components_Baeume")
weights_raw   <- read_or_stop(input_file, "Weights")
scales_raw    <- read_or_stop(input_file, "Scales")

# Erwartete Schlüsselspalten prüfen
stop_if_missing <- function(df, cols, name){
  miss <- setdiff(cols, names(df))
  if (length(miss) > 0) stop(paste0("In '", name, "' fehlen Spalten: ", paste(miss, collapse=", ")))
}

stop_if_missing(weights_raw, c("component","criterion","weight"), "Weights")
stop_if_missing(scales_raw,  c("criterion","scale_type"), "Scales")

# Scales-Defaults setzen (falls Felder fehlen)
scales <- scales_raw %>%
  mutate(
    direction        = coalesce(direction, "higher_better"),
    min              = as.numeric(min),
    max              = as.numeric(max),
    ordinal_levels   = coalesce(ordinal_levels, ""),
    ordinal_scores   = coalesce(ordinal_scores, ""),
    bool_true_score  = as.numeric(coalesce(bool_true_score, 1)),
    bool_false_score = as.numeric(coalesce(bool_false_score, 0))
  )

# ------------------------------------------------------------
# 3) Hilfsfunktionen: Normalisierung / Mapping
# ------------------------------------------------------------
normalize_numeric <- function(x, min_val, max_val, direction = "higher_better"){
  x_num <- suppressWarnings(as.numeric(x))
  res <- rep(NA_real_, length(x_num))
  ok <- !is.na(x_num) & !is.na(min_val) & !is.na(max_val) & (max_val > min_val)
  # clamp
  x_num[ok] <- pmax(pmin(x_num[ok], max_val), min_val)
  if (direction == "higher_better") {
    res[ok] <- (x_num[ok] - min_val) / (max_val - min_val)
  } else {
    res[ok] <- (max_val - x_num[ok]) / (max_val - min_val)
  }
  # auf [0,1] klemmen
  res <- pmax(pmin(res, 1), 0)
  res
}

score_ordinal <- function(val, levels_str, scores_str = "", direction = "higher_better"){
  # val ist Character; levels_str "hoch|mittel|niedrig"
  levs <- str_split(levels_str, "\\|", simplify = TRUE)
  levs <- levs[levs != ""]
  if (length(levs) == 0) return(rep(NA_real_, length(val)))

  # Scores parsen (optional)
  if (scores_str != "") {
    scrs <- as.numeric(str_split(scores_str, "\\|", simplify = TRUE))
    # ggf. auf 0..1 normieren
    scrs <- (scrs - min(scrs, na.rm=TRUE)) / (max(scrs, na.rm=TRUE) - min(scrs, na.rm=TRUE))
  } else {
    # gleichmäßig verteilt
    scrs <- seq(0, 1, length.out = length(levs))
    if (direction == "lower_better") scrs <- rev(scrs)
  }

  # Matchen
  idx <- match(tolower(trimws(val)), tolower(trimws(levs)))
  out <- ifelse(is.na(idx), NA_real_, scrs[idx])
  out
}

score_bool <- function(val, true_score = 1, false_score = 0){
  v <- tolower(trimws(as.character(val)))
  out <- ifelse(v %in% c("1","true","ja","yes","y"), true_score,
                ifelse(v %in% c("0","false","nein","no","n"), false_score, NA_real_))
  # auf [0..1] normieren falls nötig
  rng <- range(c(true_score, false_score), na.rm = TRUE)
  if (diff(rng) > 0) out <- (out - rng[1]) / (rng[2] - rng[1])
  out
}

# ------------------------------------------------------------
# 4) Kernfunktion: Komponenten scoren
# ------------------------------------------------------------
# Erwartete Rohdatenstruktur:
# - Erste Spalte: ID-Name (z. B. "belag") – wird als 'id' verwendet
# - Weitere Spalten: Kriteriumsspalten, exakt wie in Weights/Scales$criterion
score_component <- function(raw_df, id_col, component_name, weights_tbl, scales_tbl){

  # Sicherstellen: ID-Spalte vorhanden
  stop_if_missing(raw_df, id_col, paste0("Components_", component_name))

  # **Fix** gegen Typkonflikte: zuerst alle Nicht-ID-Spalten in Character wandeln
  df_long <- raw_df %>%
    rename(id = !!id_col) %>%
    mutate(across(-id, as.character)) %>%           # <— WICHTIGER FIX
    pivot_longer(
      -id,
      names_to  = "criterion",
      values_to = "wert"
    )

  # Relevante Gewichte für diese Komponente
  w <- weights_tbl %>%
    filter(component == component_name) %>%
    group_by(component) %>%
    mutate(weight = as.numeric(weight),
           weight = ifelse(is.na(weight), 0, weight),
           weight_norm = ifelse(sum(weight, na.rm=TRUE) > 0, weight/sum(weight, na.rm=TRUE), 0)) %>%
    ungroup() %>%
    select(criterion, weight_norm)

  # Join mit Scales & Weights
  joined <- df_long %>%
    left_join(scales_tbl,  by = "criterion") %>%
    left_join(w,           by = "criterion")

  # Score je Zeile
  scored <- joined %>%
    mutate(
      weight_norm = coalesce(weight_norm, 0),
      scale_type  = tolower(scale_type),
      direction   = tolower(direction),

      score = case_when(
        scale_type == "numeric" ~ normalize_numeric(wert, min, max, direction),
        scale_type == "ordinal" ~ score_ordinal(wert, ordinal_levels, ordinal_scores, direction),
        scale_type == "bool"    ~ score_bool(wert, bool_true_score, bool_false_score),
        TRUE ~ NA_real_
      ),
      weighted_score = score * weight_norm
    )

  # KPI-Checks (optional)
  missing_scales <- scored %>% filter(is.na(score) & !is.na(wert)) %>%
    distinct(criterion)
  if (nrow(missing_scales) > 0) {
    message("⚠️ Kein Scale-Mapping für Kriterien (", component_name, "): ",
            paste(missing_scales$criterion, collapse=", "))
  }

  # Aggregation pro ID
  total <- scored %>%
    group_by(id) %>%
    summarise(
      total_score   = sum(weighted_score, na.rm = TRUE),
      n_criteria    = n(),
      n_scored      = sum(!is.na(score)),
      .groups = "drop"
    ) %>%
    arrange(desc(total_score)) %>%
    mutate(rank = row_number())

  list(
    breakdown = scored,   # Detail je Kriterium
    summary   = total     # Gesamtwertung
  )
}

# ------------------------------------------------------------
# 5) Scoring ausführen (alle drei Komponenten)
# ------------------------------------------------------------

# Annahme: Erste Spalte je Sheet heißt wie folgt:
id_belaege   <- names(raw_belaege)[1]
id_leitungen <- names(raw_leitungen)[1]
id_baeume    <- names(raw_baeume)[1]

res_belaege   <- score_component(raw_belaege,   id_col = id_belaege,   component_name = "Belaege",   weights_tbl = weights_raw, scales_tbl = scales)
res_leitungen <- score_component(raw_leitungen, id_col = id_leitungen, component_name = "Leitungen", weights_tbl = weights_raw, scales_tbl = scales)
res_baeume    <- score_component(raw_baeume,    id_col = id_baeume,    component_name = "Baeume",    weights_tbl = weights_raw, scales_tbl = scales)

# ------------------------------------------------------------
# 6) Ergebnisse ansehen
# ------------------------------------------------------------
print(head(res_belaege$summary,   10))
print(head(res_leitungen$summary, 10))
print(head(res_baeume$summary,    10))

# ------------------------------------------------------------
# 7) Plots (Balken Top/alle) & Export
# ------------------------------------------------------------
plot_rank <- function(sum_df, title){
  sum_df %>%
    mutate(id = fct_reorder(id, total_score)) %>%
    ggplot(aes(x = id, y = total_score)) +
    geom_col() +
    coord_flip() +
    labs(x = NULL, y = "Gesamtscore (0–1)", title = title) +
    theme_minimal(base_size = 12)
}

p_belaege   <- plot_rank(res_belaege$summary,   "Ranking – Beläge")
p_leitungen <- plot_rank(res_leitungen$summary, "Ranking – Leitungen")
p_baeume    <- plot_rank(res_baeume$summary,    "Ranking – Bäume")

ggsave(file.path(output_dir, "Ranking_Belaege.png"),   p_belaege,   width = 8, height = 6, dpi = 150)
ggsave(file.path(output_dir, "Ranking_Leitungen.png"), p_leitungen, width = 8, height = 6, dpi = 150)
ggsave(file.path(output_dir, "Ranking_Baeume.png"),    p_baeume,    width = 8, height = 6, dpi = 150)

# ------------------------------------------------------------
# 8) Export Excel (Scores + Breakdown)
# ------------------------------------------------------------
export_list <- list(
  Scores_Belaege    = res_belaege$summary,
  Scores_Leitungen  = res_leitungen$summary,
  Scores_Baeume     = res_baeume$summary,
  Breakdown_Belaege   = res_belaege$breakdown %>% select(id, criterion, wert, score, weight_norm, weighted_score),
  Breakdown_Leitungen = res_leitungen$breakdown %>% select(id, criterion, wert, score, weight_norm, weighted_score),
  Breakdown_Baeume    = res_baeume$breakdown %>% select(id, criterion, wert, score, weight_norm, weighted_score)
)

writexl::write_xlsx(export_list, output_xlsx)

message("✅ Fertig! Exportiert: ",
        "\n  - ", output_xlsx,
        "\n  - ", file.path(output_dir, "Ranking_Belaege.png"),
        "\n  - ", file.path(output_dir, "Ranking_Leitungen.png"),
        "\n  - ", file.path(output_dir, "Ranking_Baeume.png"))

# ============================================================
# Ende
# ============================================================

```

