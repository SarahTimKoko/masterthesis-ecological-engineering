---
title: "Zeitstrahl_Analyse"
author: "Sarah Pfeiffer"
date: today
format: 
    html:
        toc: true
        code-fold: false

---
# Zeitstrahl-Analyse
Ziel: 

## Libraries Laden

```{r}
library(tidyverse)
library(readr)
library(ggplot2)
library(forcats) # Für fct_rev()
library(tidyr)   # Für complete()
library(purrr)   # Für map()

```

## 1. Daten importieren
Ziel: Lädt alle 5 CSV-Dateien, die für diese Analyse notwendig sind

```{r}
# --- A. Input 1: Die "Sieger" (Ergebnis aus MCA) ---
df_sieger_belaege_roh <- read_csv2("02_export/tables/mca_top3_belaege_pro_szenario.csv")
df_sieger_baeume_roh  <- read_csv2("02_export/tables/mca_top3_baeume_pro_szenario.csv")

# --- B. Input 2: Die "Stammdaten" (um Lebensdauer zu holen) ---
df_belaege_stammdaten <- read_delim("01_data_input/Belaege_tidy.csv", delim = ";")
df_baeume_stammdaten  <- read_delim("01_data_input/Baeume_tidy.csv", delim = ";")

# --- C. Input 3: Die "Konstanten" (Leitungen) ---
df_leitungen_roh <- read_csv2("01_data_input/Leitungen_IST.csv")


# --- PRÜFUNG BLOCK 1 ---
print("--- Check: Wurden die Sieger geladen? ---")
head(df_sieger_belaege_roh, 6)

print("--- Check: Sind die Leitungen da? ---")
# Hier müssen Spalten wie 'Leitungstyp' und 'Techn_Nutzungsdauer_a' (oder ähnlich) stehen
colnames(df_leitungen_roh)

```

## 2. Daten Aufbereiten
Ziel: Alle Komponenten (Leitungen, Beläge, Bäume) in ein einheitliches Format bringen (szenario, kategorie, komponente, lebensdauer).

```{r}

## 2. Daten harmonisieren

# --- 2.1 Leitungen aufbereiten (MIT VARIANTENVERGLEICH) ---
# Wir nehmen Graben UND Kabelzug
# Und wir nehmen BEIDE Lebensdauern (Technisch & Material)

df_leitungen <- df_leitungen_roh %>%
  # 1. Filter
  filter(Eingriffs_Typ %in% c("Graben", "Kabelzug")) %>%
  
  # 2. Pivotieren: Aus 2 Spalten werden 2 Zeilen pro Leitung
  pivot_longer(
    cols = c(Techn_Nutzungsdauer_a, Material_Lebensdauer_a),
    names_to = "lebensdauer_typ",
    values_to = "lebensdauer_wert"
  ) %>%
  
  # 3. Namen anpassen (damit man sie im Plot unterscheidet)
  mutate(
    szenario = "Alle Szenarien", 
    kategorie = "Leitung",
    # Neuer Name z.B.: "Abwasser (Techn.)" vs. "Abwasser (Mat.)"
    komponente = paste0(Leitungstyp, " (", 
                        if_else(lebensdauer_typ == "Techn_Nutzungsdauer_a", "Techn.", "Mat."), 
                        ")")
  ) %>%
  
  select(szenario, kategorie, komponente, lebensdauer = lebensdauer_wert)

# --- 2.2 Beläge aufbereiten ---
df_sieger_belaege_ld <- df_sieger_belaege_roh %>%
  left_join(df_belaege_stammdaten %>% select(option, lebensdauer), by = "option") %>%
  select(szenario, kategorie = belagskategorie, komponente = option, lebensdauer)

# --- 2.3 Bäume aufbereiten ---
df_sieger_baeume_ld <- df_sieger_baeume_roh %>%
  left_join(df_baeume_stammdaten %>% select(baumart, lebensdauer), by = "baumart") %>%
  select(szenario, kategorie = baumkategorie, komponente = baumart, lebensdauer)


# --- PRÜFUNG BLOCK 2 ---
print("--- Check 1: Sind die Leitungen verdoppelt? ---")
# Du solltest jetzt z.B. "Abwasser (Techn.)" UND "Abwasser (Mat.)" sehen
table(df_leitungen$komponente)

print("--- Check 2: Haben alle eine Lebensdauer? ---")
summary(df_leitungen$lebensdauer)

```

## 3. Master-Tabelle erstellen
Ziel: Eine "Master-Tabelle" erstellen, die Jede Komponente für Jedes Szenario enthält.

```{r}
## 3. Master-Tabelle erstellen

# Ziel: Eine grosse Tabelle bauen, die für jedes Szenario (S0-S3) alle Akteure enthält.
# NEU: Wir nehmen jetzt ALLE Top-3-Kandidaten mit, nicht nur den Sieger.

# 1. Liste der Szenarien aus den Siegern holen
szenario_liste <- unique(df_sieger_belaege_ld$szenario)

# 2. Leitungen für jedes Szenario duplizieren
# (Wir haben 14 Leitungs-Varianten und kopieren sie für S0, S1, S2, S3)
df_leitungen_final <- df_leitungen %>%
  select(-szenario) %>% 
  crossing(szenario = szenario_liste) %>% 
  select(szenario, kategorie, komponente, lebensdauer)

# 3. Die Sieger zusammenfügen (ALLE Top 3)
# Wir nehmen einfach die Tabellen, die wir in Block 2 vorbereitet haben.
# Da die Input-CSVs ('mca_top3_...') bereits genau 3 Einträge pro Szenario haben,
# müssen wir hier NICHTS mehr filtern oder slicen.

df_master <- bind_rows(
  df_leitungen_final,
  df_sieger_belaege_ld, # Enthält jetzt Rang 1, 2 und 3
  df_sieger_baeume_ld   # Enthält jetzt Rang 1, 2 und 3
)


# --- PRÜFUNG BLOCK 3 ---

print("--- Check 1: Stimmt die Anzahl Zeilen? ---")
# Rechnung NEU:
# Leitungen: 14 Typen * 4 Szenarien = 56
# Beläge:     3 Typen * 4 Szenarien = 12
# Bäume:      3 Typen * 4 Szenarien = 12
# TOTAL:      56 + 12 + 12 = 80 Zeilen
nrow(df_master)

print("--- Check 2: Sind pro Szenario 3 Bäume da? ---")
df_master %>% 
  filter(szenario == "Szenario 0: Baseline (IST)", kategorie == "Grosskronige Arten") 
  # Hinweis: Die Kategorie heisst evtl. anders, je nach Daten. 
  # Besser: Wir zählen einfach pro Kategorie
  
df_master %>%
  filter(szenario == "Szenario 0: Baseline (IST)") %>%
  count(kategorie)

```

## 4. Sanierungs-Events berechnen
Ziel: Den 100-Jahres-Zeitstrahl mit allen Sanierungs-Punkten berechnen.

```{r}
## 4. Sanierungs-Events berechnen
# Ziel: Den 100-Jahres-Zeitstrahl mit allen Sanierungs-Punkten berechnen.

# --- Schritt 4.1: Alle Sanierungs-Events berechnen ---
# WICHTIG: Wir nutzen 'df_master' aus Block 3!
zeitstrahl_events <- df_master %>%
  # Erstellt für jede Komponente eine Liste von Events (z.B. 0, 40, 80)
  mutate(sanierungs_jahr = map(lebensdauer, ~ seq(from = 0, to = 100, by = .x))) %>%
  # Klappt die Listen-Spalte in Zeilen aus
  unnest(sanierungs_jahr) %>%
  # Entfernt das Baujahr (0) und alles nach 100 (wir wollen nur Sanierungen sehen)
  filter(sanierungs_jahr > 0, sanierungs_jahr <= 100) %>%
  # Sortieren und Auswählen
  select(szenario, kategorie, komponente, lebensdauer, sanierungs_jahr) %>%
  arrange(szenario, komponente, sanierungs_jahr)
  
# --- Schritt 4.2: Speichern ---
print("--- Zeitstrahl-Event-Liste (Auszug) ---")
print(zeitstrahl_events, n = 20)

write_csv2(
  zeitstrahl_events,
  file = "02_export/tables/zeitstrahl_events_100a.csv"
)

# --- PRÜFUNG BLOCK 4 ---

print("--- Check 1: Anzahl Events insgesamt ---")
nrow(zeitstrahl_events) 
# Sollte einige Hundert sein (80 Komponenten * ca. 1-2 Eingriffe)

print("--- Check 2: Beispiel Selbstheilender Asphalt (S0) ---")
# Der hält ca. 42-45 Jahre. Wir erwarten Eingriffe bei ca. 45 und 90.
zeitstrahl_events %>%
  filter(szenario == "Szenario 0: Baseline (IST)", grepl("Asphalt", komponente))

print("--- Check 3: Gibt es noch Jahr 0? (Sollte 0 Zeilen sein) ---")
zeitstrahl_events %>% filter(sanierungs_jahr == 0)

```

## 5. Finale Synthese: Zeitstrahl-Visualisierung
Ziel: Vergleich der Sanierungs-Szenarien zur Beantwortung von H1 & H2.
```{r}
## 5. Finale Synthese: Zeitstrahl-Visualisierung (Getrennt)

# Ziel: Vergleich der Sanierungs-Szenarien (Technisch vs. Material getrennt).

# 1. Datensätze trennen
# Wir behalten IMMER alle Bäume/Beläge, aber filtern die Leitungen
events_techn <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Techn\\.\\)", komponente))

events_mat <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Mat\\.\\)", komponente))

# 2. Plot-Funktion (angepasst für Split)
plot_zeitstrahl_split <- function(data, szenario_titel, filename_suffix) {
  
  # Filtern der relevanten Szenarien (S0 vs. Vergleich)
  data_plot <- data %>%
    filter(szenario %in% c("Szenario 0: Baseline (IST)", szenario_titel)) %>%
    mutate(Hauptgruppe = case_when(
      kategorie == "Leitung" ~ "Leitungen",
      grepl("Arten", kategorie) ~ "Bäume",
      TRUE ~ "Beläge"
    ))
  
  p <- ggplot(data_plot, aes(x = sanierungs_jahr, 
                             y = fct_reorder(komponente, lebensdauer), 
                             color = Hauptgruppe)) +
    geom_vline(xintercept = seq(0, 100, 10), color = "grey92") +
    geom_point(size = 3.5, alpha = 0.9) +
    facet_wrap(~szenario, ncol = 1, scales = "free_y") +
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    labs(title = NULL, x = "Jahr", y = NULL, color = NULL) +
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      strip.background = element_rect(fill = "grey95", color = NA),
      strip.text = element_text(face = "bold", hjust = 0),
      axis.text = element_text(color = "black")
    )
  
  # Speichern
  ggsave(paste0("02_export/plots/Zeitstrahl_", filename_suffix, ".png"), 
         plot = p, width = 10, height = 10, dpi = 300)
  print(p)
}

# --- PLOTS GENERIEREN (TECHNISCH) ---
plot_zeitstrahl_split(events_techn, "Szenario 1: Forschungsfokus", "Techn_S0_vs_S1")
plot_zeitstrahl_split(events_techn, "Szenario 2: Radikale Vermeidung", "Techn_S0_vs_S2")
plot_zeitstrahl_split(events_techn, "Szenario 3: Radikaler Lebenszyklus", "Techn_S0_vs_S3")

# --- PLOTS GENERIEREN (MATERIAL) ---
plot_zeitstrahl_split(events_mat, "Szenario 1: Forschungsfokus", "Mat_S0_vs_S1")
plot_zeitstrahl_split(events_mat, "Szenario 2: Radikale Vermeidung", "Mat_S0_vs_S2")
plot_zeitstrahl_split(events_mat, "Szenario 3: Radikaler Lebenszyklus", "Mat_S0_vs_S3")
```

## 6. Optimierter Zeitstrahl
Ziel: Lösungsdarstellung für so wenige Sanierungszyklen wie möglich

```{r}
## 6. Optimierung: Bündelung (Getrennt nach Logik)

# Funktion zur Berechnung der Bündelung
optimize_events <- function(data, anchors, toleranz = 15) {
  data %>%
    mutate(
      is_fix = kategorie == "Leitung",
      jahr_optimiert = case_when(
        is_fix ~ sanierungs_jahr,
        # Dynamische Prüfung gegen alle Ankerjahre
        TRUE ~ {
          # Finde den nächsten Anker
          closest_anchor <- map_dbl(sanierungs_jahr, ~ {
            diffs <- .x - anchors
            # Nur Anker in der Zukunft oder Gegenwart betrachten, 
            # zu denen man "vorziehen" kann?
            # Hier: Einfache Nähe (+/- Toleranz)
            valid_anchors <- anchors[abs(diffs) <= toleranz]
            if(length(valid_anchors) > 0) valid_anchors[1] else .x
          })
          closest_anchor
        }
      ),
      wurde_verschoben = sanierungs_jahr != jahr_optimiert
    )
}

# 1. Optimierung TECHNISCH (Anker 50, 80)
df_opt_techn <- optimize_events(events_techn, anchors = c(50, 80))

# 2. Optimierung MATERIAL (Anker 70, 100 - Längere Zyklen!)
df_opt_mat   <- optimize_events(events_mat, anchors = c(70, 100))

# Speichern
write_csv2(df_opt_techn, "02_export/tables/zeitstrahl_optimiert_techn.csv")
write_csv2(df_opt_mat, "02_export/tables/zeitstrahl_optimiert_mat.csv")

```

## 7. Visualisierung

```{r}
## 7. Visualisierung: Optimierter Zeitstrahl (Scientific Style)

plot_opt_split <- function(data, szenario_name, anchors, filename) {
  
  data_plot <- data %>% filter(szenario == szenario_name)
  
  p <- ggplot(data_plot, aes(y = fct_reorder(komponente, lebensdauer))) +
    
    # 1. Anker-Linien (Die "Magnete")
    geom_vline(xintercept = anchors, color = "firebrick", linetype = "dashed", alpha = 0.6) +
    
    # 2. Pfeile (Verschiebung)
    geom_segment(aes(x = sanierungs_jahr, xend = jahr_optimiert, yend = komponente),
                 arrow = arrow(length = unit(0.15, "cm"), type = "closed"), 
                 color = "grey60",
                 data = filter(data_plot, wurde_verschoben)) +
    
    # 3. Ghost-Punkte (Original-Zeitpunkt) - HIER ANGEPASST!
    geom_point(aes(x = sanierungs_jahr), 
               shape = 21,          # Kreis mit Rand und Füllung
               color = "grey30",    # Rand: Dunkelgrau/Fast Schwarz (gut sichtbar)
               fill = "white",      # Füllung: Weiss (oder "grey95")
               size = 2.5, 
               alpha = 0.7) +       # Leicht transparent
    
    # 4. Optimierte Punkte (Finaler Zeitpunkt)
    geom_point(aes(x = jahr_optimiert, 
                   color = case_when(kategorie == "Leitung" ~ "Leitungen",
                                     grepl("Arten", kategorie) ~ "Bäume",
                                     TRUE ~ "Beläge")), 
               size = 3.5) +
    
    # Skalen & Farben
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    
    # Clean Labels
    labs(title = NULL, 
         subtitle = paste(szenario_name), 
         x = "Jahr (Pfeil zeigt Bündelung)", y = NULL, color = NULL) +
    
    # Theme Classic
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      axis.text = element_text(color = "black")
    )
  
  ggsave(filename, plot = p, width = 10, height = 7, dpi = 300)
  print(p)
}

# --- PLOTS TECHNISCH (Anker 50/80) ---
plot_opt_split(df_opt_techn, "Szenario 0: Baseline (IST)", c(50, 80), "02_export/plots/Optimierung_Techn_S0.png")
plot_opt_split(df_opt_techn, "Szenario 1: Forschungsfokus", c(50, 80), "02_export/plots/Optimierung_Techn_S1.png")
plot_opt_split(df_opt_techn, "Szenario 2: Radikale Vermeidung", c(50, 80), "02_export/plots/Optimierung_Techn_S2.png")
plot_opt_split(df_opt_techn, "Szenario 3: Radikaler Lebenszyklus", c(50, 80), "02_export/plots/Optimierung_Techn_S3.png")

# --- PLOTS MATERIAL (Anker 70/100) ---
plot_opt_split(df_opt_mat, "Szenario 0: Baseline (IST)", c(70, 100), "02_export/plots/Optimierung_Mat_S0.png")
plot_opt_split(df_opt_mat, "Szenario 1: Forschungsfokus", c(70, 100), "02_export/plots/Optimierung_Mat_S1.png")
plot_opt_split(df_opt_mat, "Szenario 2: Radikale Vermeidung", c(70, 100), "02_export/plots/Optimierung_Mat_S2.png")
plot_opt_split(df_opt_mat, "Szenario 3: Radikaler Lebenszyklus", c(70, 100), "02_export/plots/Optimierung_Mat_S3.png")
```



