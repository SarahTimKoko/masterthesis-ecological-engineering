---
title: "Zeitstrahl_Analyse"
author: "Sarah Pfeiffer"
date: today
format: 
    html:
        toc: true
        code-fold: false

---
# Zeitstrahl-Analyse
Ziel: 

## Libraries Laden

```{r}
library(tidyverse)
library(readr)
library(ggplot2)
library(forcats) # Für fct_rev()
library(tidyr)   # Für complete()
library(purrr)   # Für map()
library(ggtext)

```

## 1. Daten importieren
Ziel: Lädt alle 5 CSV-Dateien, die für diese Analyse notwendig sind

```{r}
# --- A. Input 1: Die "Sieger" (Ergebnis aus MCA) ---
df_sieger_belaege_roh <- read_csv2("02_export/tables/mca_top3_belaege_pro_szenario.csv")
df_sieger_baeume_roh  <- read_csv2("02_export/tables/mca_top3_baeume_pro_szenario.csv")

# --- B. Input 2: Die "Stammdaten" (um Lebensdauer zu holen) ---
df_belaege_stammdaten <- read_delim("01_data_input/Belaege_tidy.csv", delim = ";")
df_baeume_stammdaten  <- read_delim("01_data_input/Baeume_tidy.csv", delim = ";")

# --- C. Input 3: Die "Konstanten" (Leitungen) ---
df_leitungen_roh <- read_csv2("01_data_input/Leitungen_IST.csv")

```


```{r}
#| include: false
# --- PRÜFUNG BLOCK 1 ---
print("--- Check: Wurden die Sieger geladen? ---")
head(df_sieger_belaege_roh, 6)

print("--- Check: Sind die Leitungen da? ---")
# Hier müssen Spalten wie 'Leitungstyp' und 'Techn_Nutzungsdauer_a' (oder ähnlich) stehen
colnames(df_leitungen_roh)

```

## 2. Daten Aufbereiten
Ziel: Alle Komponenten (Leitungen, Beläge, Bäume) in ein einheitliches Format bringen (szenario, kategorie, komponente, lebensdauer).

```{r}

## 2. Daten harmonisieren

# --- 2.1 Leitungen aufbereiten (Nur Graben = Konflikt) ---
df_leitungen <- df_leitungen_roh %>%
  # WICHTIG: Wir filtern streng auf "Graben".
  # "Kabelzug" ist kein Konflikt für Bäume/Beläge und wird ignoriert.
  filter(Eingriffs_Typ == "Graben") %>%
  
  # Pivotieren für Sensitivitätsanalyse (Technisch vs. Material)
  pivot_longer(
    cols = c(Techn_Nutzungsdauer_a, Material_Lebensdauer_a),
    names_to = "lebensdauer_typ",
    values_to = "lebensdauer_wert"
  ) %>%
  
  mutate(
    szenario = "Alle Szenarien", 
    kategorie = "Leitung",
    # Unterscheidung im Namen
    komponente = paste0(Leitungstyp, " (", 
                        if_else(lebensdauer_typ == "Techn_Nutzungsdauer_a", "Techn.", "Mat."), 
                        ")")
  ) %>%
  
  select(szenario, kategorie, komponente, lebensdauer = lebensdauer_wert)

# --- 2.2 Beläge aufbereiten (Unverändert) ---
df_sieger_belaege_ld <- df_sieger_belaege_roh %>%
  left_join(df_belaege_stammdaten %>% select(option, lebensdauer), by = "option") %>%
  select(szenario, kategorie = belagskategorie, komponente = option, lebensdauer)

# --- 2.3 Bäume aufbereiten (Unverändert) ---
df_sieger_baeume_ld <- df_sieger_baeume_roh %>%
  left_join(df_baeume_stammdaten %>% select(baumart, lebensdauer), by = "baumart") %>%
  select(szenario, kategorie = baumkategorie, komponente = baumart, lebensdauer)

```

## 3. Master-Tabelle erstellen
Ziel: Eine "Master-Tabelle" erstellen, die Jede Komponente für Jedes Szenario enthält.

```{r}
## 3. Master-Tabelle erstellen

# Ziel: Master-Tabelle mit Info, wer der "Sieger" (Rang 1) ist.

# 1. Liste der Szenarien
szenario_liste <- unique(df_sieger_belaege_ld$szenario)

# 2. Leitungen (Rang 0 = Boss)
df_leitungen_final <- df_leitungen %>%
  select(-szenario) %>% 
  crossing(szenario = szenario_liste) %>% 
  select(szenario, kategorie, komponente, lebensdauer) %>%
  mutate(rang = 0) # Leitungen haben immer Vorrang

# 3. Sieger Beläge und Bäume (Wir fügen den Rang hinzu)
# Wir gehen davon aus, dass die Input-CSVs sortiert sind (Platz 1 oben)
df_belaege_mit_rang <- df_sieger_belaege_ld %>%
  group_by(szenario) %>%
  mutate(rang = row_number()) %>% # Erstellt 1, 2, 3
  ungroup()

df_baeume_mit_rang <- df_sieger_baeume_ld %>%
  group_by(szenario) %>%
  mutate(rang = row_number()) %>%
  ungroup()

# 4. Zusammenfügen
df_master <- bind_rows(
  df_leitungen_final,
  df_belaege_mit_rang,
  df_baeume_mit_rang
)

```



```{r}
#| include: false
# --- PRÜFUNG BLOCK 3 ---
print("--- Check 1: Stimmt die Anzahl Zeilen? ---")
# Rechnung NEU:
# Leitungen: 10 Typen * 4 Szenarien = 40
# Beläge:     3 Typen * 4 Szenarien = 12
# Bäume:      3 Typen * 4 Szenarien = 12
# TOTAL:      40 + 12 + 12 = 64 Zeilen
nrow(df_master)

print("--- Check 2: Sind pro Szenario 3 Bäume da? ---")
df_master %>% 
  filter(szenario == "Szenario 0: Baseline (IST)", kategorie == "Grosskronige Arten") 
  # Hinweis: Die Kategorie heisst evtl. anders, je nach Daten. 
  # Besser: Wir zählen einfach pro Kategorie
  
df_master %>%
  filter(szenario == "Szenario 0: Baseline (IST)") %>%
  count(kategorie)

print("--- Check: Existiert die Spalte 'rang'? ---")
head(df_master)

```

## 4. Sanierungs-Events berechnen
Ziel: Den 100-Jahres-Zeitstrahl mit allen Sanierungs-Punkten berechnen.

```{r}
## 4. Sanierungs-Events berechnen

zeitstrahl_events <- df_master %>%
  mutate(sanierungs_jahr = map(lebensdauer, ~ seq(from = 0, to = 100, by = .x))) %>%
  unnest(sanierungs_jahr) %>%
  filter(sanierungs_jahr > 0, sanierungs_jahr <= 100) %>%
  
  # WICHTIG: 'rang' muss hier im select stehen!
  select(szenario, kategorie, komponente, lebensdauer, sanierungs_jahr, rang) %>%
  
  arrange(szenario, komponente, sanierungs_jahr)

write_csv2(zeitstrahl_events, "02_export/tables/zeitstrahl_events_100a.csv")
```



```{r}
#| include: false
# --- PRÜFUNG BLOCK 4 ---
print("--- Check 1: Anzahl Events insgesamt ---")
nrow(zeitstrahl_events) 

print("--- Check 2: Beispiel Selbstheilender Asphalt (S0) ---")
# Der hält ca. 42-45 Jahre. Wir erwarten Eingriffe bei ca. 45 und 90.
zeitstrahl_events %>%
  filter(szenario == "Szenario 0: Baseline (IST)", grepl("Asphalt", komponente))

print("--- Check 3: Gibt es noch Jahr 0? (Sollte 0 Zeilen sein) ---")
zeitstrahl_events %>% filter(sanierungs_jahr == 0)

```

## 5. Finale Synthese: Zeitstrahl-Visualisierung
Ziel: Vergleich der Sanierungs-Szenarien zur Beantwortung von H1 & H2.

```{r}
## 5. Finale Synthese: Zeitstrahl-Visualisierung (Getrennt)

# Ziel: Vergleich der Sanierungs-Szenarien (Technisch vs. Material getrennt).

# 1. Datensätze trennen
events_techn <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Techn\\.\\)", komponente))

events_mat <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Mat\\.\\)", komponente))

# 2. Plot-Funktion (angepasst mit Kursivschrift)
plot_zeitstrahl_split <- function(data, szenario_titel, filename_suffix) {
  
  # A. Daten filtern & Labels formatieren
  data_plot <- data %>%
    filter(szenario %in% c("Szenario 0: Baseline (IST)", szenario_titel)) %>%
    mutate(
      Hauptgruppe = case_when(
        kategorie == "Leitung" ~ "Leitungen",
        grepl("Arten", kategorie) ~ "Bäume",
        TRUE ~ "Beläge"
      ),
      # 1. HTML-Formatierung für Kursivschrift (gleiche Logik wie oben)
      label_raw = case_when(
        str_detect(kategorie, "Arten") ~ str_replace(komponente, "^([^(]+)(.*)$", "<i>\\1</i>\\2"),
        TRUE ~ komponente
      ),
      # 2. Sortierung beibehalten
      label_formatted = fct_reorder(label_raw, lebensdauer)
    )
  
  # B. Plot erstellen
  p <- ggplot(data_plot, aes(x = sanierungs_jahr, 
                             y = label_formatted, # Hier die formatierte Spalte nutzen
                             color = Hauptgruppe)) +
    
    geom_vline(xintercept = seq(0, 100, 10), color = "grey92") +
    geom_point(size = 3.5, alpha = 0.9) +
    
    facet_wrap(~szenario, ncol = 1, scales = "free_y") +
    
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    # WICHTIG: Damit HTML nicht kaputt geht
    scale_y_discrete(labels = function(x) x) +
    
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    
    labs(title = NULL, x = "Jahr", y = NULL, color = NULL) +
    
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      strip.background = element_blank(),
      strip.text = element_text(face = "plain", hjust = 0, size = 11),
      
      axis.text = element_text(color = "black"),
      # WICHTIG: Markdown aktivieren!
      axis.text.y = ggtext::element_markdown(color = "black")
    )
  
  ggsave(paste0("02_export/plots/Zeitstrahl_", filename_suffix, ".png"), 
         plot = p, width = 10, height = 10, dpi = 300)
  print(p)
}

# --- PLOTS GENERIEREN (TECHNISCH) ---
plot_zeitstrahl_split(events_techn, "Szenario 1: Forschungsfokus", "Techn_S0_vs_S1")
plot_zeitstrahl_split(events_techn, "Szenario 2: Radikale Vermeidung", "Techn_S0_vs_S2")
plot_zeitstrahl_split(events_techn, "Szenario 3: Radikaler Lebenszyklus", "Techn_S0_vs_S3")

# --- PLOTS GENERIEREN (MATERIAL) ---
plot_zeitstrahl_split(events_mat, "Szenario 1: Forschungsfokus", "Mat_S0_vs_S1")
plot_zeitstrahl_split(events_mat, "Szenario 2: Radikale Vermeidung", "Mat_S0_vs_S2")
plot_zeitstrahl_split(events_mat, "Szenario 3: Radikaler Lebenszyklus", "Mat_S0_vs_S3")
```

## 6. Optimierter Zeitstrahl
Ziel: Lösungsdarstellung für so wenige Sanierungszyklen wie möglich

```{r}
# 1. DEFINITION DER LOGIK-FUNKTION
optimize_events_final <- function(data, anchors_tiefbau, tol_tiefbau = 15, tol_oberflaeche = 10) {
  
  # --- HILFSFUNKTION: Berechnung einer einzelnen Komponente ---
  process_single_component <- function(comp_df, anchors_tief, anchors_surface = NULL) {
    comp_df <- comp_df %>% arrange(sanierungs_jahr)
    
    is_fix_pipe <- str_detect(comp_df$komponente[1], "Abwasser|Regenwasser")
    is_belag    <- !str_detect(comp_df$kategorie[1], "Leitung|Arten")
    lebensdauer <- comp_df$lebensdauer[1]
    
    theo_vec <- numeric(nrow(comp_df))
    opt_vec  <- numeric(nrow(comp_df))
    last_optimized_year <- 0
    
    for(i in 1:nrow(comp_df)) {
      # 1. THEORIE (Weisser Punkt): Immer vom letzten blauen Punkt aus!
      if (is_fix_pipe) {
        bedarf <- comp_df$sanierungs_jahr[i]
      } else {
        bedarf <- last_optimized_year + lebensdauer
      }
      
      # 2. OPTIMIERUNG (Blauer Punkt)
      if (is_fix_pipe) {
        opt <- bedarf
      } else {
        opt <- NA_real_
        # A) Check Tiefbau
        tol_val <- if(is_belag) tol_oberflaeche else tol_tiefbau
        diffs_t <- bedarf - anchors_tief
        matches_t <- anchors_tief[abs(diffs_t) <= tol_val]
        if(length(matches_t) > 0) opt <- matches_t[which.min(abs(bedarf - matches_t))]
        
        # B) Check Oberfläche (nur Beläge)
        if(is.na(opt) && is_belag && !is.null(anchors_surface)) {
          diffs_s <- bedarf - anchors_surface
          matches_s <- anchors_surface[abs(diffs_s) <= tol_oberflaeche]
          if(length(matches_s) > 0) opt <- matches_s[which.min(abs(bedarf - matches_s))]
        }
        if(is.na(opt)) opt <- bedarf
      }
      theo_vec[i] <- bedarf
      opt_vec[i]  <- opt
      last_optimized_year <- opt
    }
    comp_df$theoretischer_bedarf <- theo_vec
    comp_df$jahr_optimiert       <- opt_vec
    return(comp_df)
  }
  
  # --- HAUPTABLAUF ---
  drivers <- data %>% filter(str_detect(kategorie, "Leitung|Arten") | rang == 1)
  followers <- data %>% filter(!str_detect(kategorie, "Leitung|Arten") & rang > 1)
  
  drivers_processed <- drivers %>%
    group_by(szenario, komponente) %>%
    group_split() %>%
    map_dfr(~ process_single_component(.x, anchors_tiefbau, anchors_surface = NULL))
  
  new_surface_anchors <- drivers_processed %>%
    filter(!str_detect(kategorie, "Leitung|Arten"), rang == 1) %>%
    group_by(szenario) %>%
    summarise(anchors = list(unique(jahr_optimiert))) %>%
    deframe()
  
  if(nrow(followers) > 0) {
    followers_processed <- followers %>%
      group_by(szenario, komponente) %>%
      group_split() %>%
      map_dfr(function(df) {
        sz <- df$szenario[1]
        surf_anchors <- if(sz %in% names(new_surface_anchors)) new_surface_anchors[[sz]] else NULL
        process_single_component(df, anchors_tiefbau, anchors_surface = surf_anchors)
      })
    result <- bind_rows(drivers_processed, followers_processed)
  } else {
    result <- drivers_processed
  }
  
  result %>%
    mutate(
      sanierungs_jahr = theoretischer_bedarf, 
      wurde_verschoben = abs(sanierungs_jahr - jahr_optimiert) > 0.1,
      differenz = jahr_optimiert - sanierungs_jahr
    )
}

# 2. BERECHNUNG DURCHFÜHREN
df_opt_techn <- optimize_events_final(events_techn, anchors_tiefbau = c(60, 80))
df_opt_mat   <- optimize_events_final(events_mat, anchors_tiefbau = c(70, 100))

# 3. EXPORT
write_csv2(df_opt_techn, "02_export/tables/zeitstrahl_optimiert_techn.csv")
write_csv2(df_opt_mat, "02_export/tables/zeitstrahl_optimiert_mat.csv")

# 4. CHECK (Nur zur Sicherheit in der Konsole)
print("Check Naturstein S0 (Sollte bei ca. 87.5 -> 80 liegen):")
df_opt_techn %>% 
  filter(szenario == "Szenario 0: Baseline (IST)", str_detect(komponente, "Naturstein")) %>%
  select(komponente, theoretischer_bedarf, jahr_optimiert) %>% 
  print()
```


```{r}
#| include: false
# Speichern
write_csv2(df_opt_techn, "02_export/tables/zeitstrahl_optimiert_techn.csv")
write_csv2(df_opt_mat, "02_export/tables/zeitstrahl_optimiert_mat.csv")

print("Hierarchische Optimierung abgeschlossen.")

```

## 7. Visualisierung

```{r}
## 7. Visualisierung

# 1. DEFINITION DER PLOT-FUNKTION (Mit HTML-Tags für Kursivschrift)
plot_opt_split <- function(data, szenario_name, anchors, filename) {
  
  # A. Labels formatieren
  data_plot <- data %>% 
    filter(szenario == szenario_name) %>%
    mutate(
      # 1. HTML-Formatierung: <i>...</i> statt Sternchen *...*
      # Regex: Nimm alles vor der ersten Klammer und packe es in <i> Tags
      label_raw = case_when(
        str_detect(kategorie, "Arten") ~ str_replace(komponente, "^([^(]+)(.*)$", "<i>\\1</i>\\2"),
        TRUE ~ komponente
      ),
      # 2. Faktor erstellen für Sortierung
      label_formatted = fct_reorder(label_raw, lebensdauer)
    )

  # B. Plot erstellen
  p <- ggplot(data_plot, aes(y = label_formatted)) + 
    
    # Anker
    geom_vline(xintercept = anchors, color = "firebrick", linetype = "dashed", alpha = 0.6) +
    
    # Pfeile
    geom_segment(aes(x = sanierungs_jahr, xend = jahr_optimiert, yend = label_formatted),
                 linewidth = 0.8, 
                 color = "grey30", 
                 arrow = arrow(length = unit(0.25, "cm"), type = "closed"), 
                 data = filter(data_plot, wurde_verschoben)) +
    
    # Weisse Punkte
    geom_point(aes(x = sanierungs_jahr), 
               shape = 21, color = "grey30", fill = "white", size = 2.5, alpha = 0.7) +
    
    # Farbige Punkte
    geom_point(aes(x = jahr_optimiert, 
                   color = case_when(kategorie == "Leitung" ~ "Leitungen",
                                     grepl("Arten", kategorie) ~ "Bäume",
                                     TRUE ~ "Beläge")), 
               size = 3.5) +
    
    # Skalen & Farben
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    # WICHTIG: Das hier stellt sicher, dass die HTML-Tags nicht "kaputt" gemacht werden
    scale_y_discrete(labels = function(x) x) + 
    scale_color_manual(values = c("Leitungen" = "black", "Bäume" = "#2ca02c", "Beläge" = "#084594")) +
    
    # Labels
    labs(title = NULL, subtitle = NULL, x = "Jahr", y = NULL, color = NULL) +
    
    # Theme
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      axis.text = element_text(color = "black"),
      # WICHTIG: Markdown aktivieren!
      axis.text.y = ggtext::element_markdown(color = "black")
    )

  ggsave(filename, plot = p, width = 10, height = 7, dpi = 300)
  print(p)
}

# 2. PLOTS GENERIEREN (Technisch)
plot_opt_split(df_opt_techn, "Szenario 0: Baseline (IST)", c(60, 80), "02_export/plots/Optimierung_Techn_S0.png")
plot_opt_split(df_opt_techn, "Szenario 1: Forschungsfokus", c(60, 80), "02_export/plots/Optimierung_Techn_S1.png")
plot_opt_split(df_opt_techn, "Szenario 2: Radikale Vermeidung", c(60, 80), "02_export/plots/Optimierung_Techn_S2.png")
plot_opt_split(df_opt_techn, "Szenario 3: Radikaler Lebenszyklus", c(60, 80), "02_export/plots/Optimierung_Techn_S3.png")

# 3. PLOTS GENERIEREN (Material)
plot_opt_split(df_opt_mat, "Szenario 0: Baseline (IST)", c(70, 100), "02_export/plots/Optimierung_Mat_S0.png")
plot_opt_split(df_opt_mat, "Szenario 1: Forschungsfokus", c(70, 100), "02_export/plots/Optimierung_Mat_S1.png")
plot_opt_split(df_opt_mat, "Szenario 2: Radikale Vermeidung", c(70, 100), "02_export/plots/Optimierung_Mat_S2.png")
plot_opt_split(df_opt_mat, "Szenario 3: Radikaler Lebenszyklus", c(70, 100), "02_export/plots/Optimierung_Mat_S3.png")
```






