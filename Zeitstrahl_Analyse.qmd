---
title: "Zeitstrahl_Analyse"
author: "Sarah Pfeiffer"
date: today
format: 
    html:
        toc: true
        code-fold: false

---
# Zeitstrahl-Analyse
Ziel: 

## Libraries Laden

```{r}
library(tidyverse)
library(readr)
library(ggplot2)
library(forcats) # Für fct_rev()
library(tidyr)   # Für complete()
library(purrr)   # Für map()

```

## 1. Daten importieren
Ziel: Lädt alle 5 CSV-Dateien, die für diese Analyse notwendig sind

```{r}
# --- A. Input 1: Die "Sieger" (Ergebnis aus MCA) ---
df_sieger_belaege_roh <- read_csv2("02_export/tables/mca_top3_belaege_pro_szenario.csv")
df_sieger_baeume_roh  <- read_csv2("02_export/tables/mca_top3_baeume_pro_szenario.csv")

# --- B. Input 2: Die "Stammdaten" (um Lebensdauer zu holen) ---
df_belaege_stammdaten <- read_delim("01_data_input/Belaege_tidy.csv", delim = ";")
df_baeume_stammdaten  <- read_delim("01_data_input/Baeume_tidy.csv", delim = ";")

# --- C. Input 3: Die "Konstanten" (Leitungen) ---
df_leitungen_roh <- read_csv2("01_data_input/Leitungen_IST.csv")

```


```{r}
#| include: false
# --- PRÜFUNG BLOCK 1 ---
print("--- Check: Wurden die Sieger geladen? ---")
head(df_sieger_belaege_roh, 6)

print("--- Check: Sind die Leitungen da? ---")
# Hier müssen Spalten wie 'Leitungstyp' und 'Techn_Nutzungsdauer_a' (oder ähnlich) stehen
colnames(df_leitungen_roh)

```

## 2. Daten Aufbereiten
Ziel: Alle Komponenten (Leitungen, Beläge, Bäume) in ein einheitliches Format bringen (szenario, kategorie, komponente, lebensdauer).

```{r}

## 2. Daten harmonisieren

# --- 2.1 Leitungen aufbereiten (Nur Graben = Konflikt) ---
df_leitungen <- df_leitungen_roh %>%
  # WICHTIG: Wir filtern streng auf "Graben".
  # "Kabelzug" ist kein Konflikt für Bäume/Beläge und wird ignoriert.
  filter(Eingriffs_Typ == "Graben") %>%
  
  # Pivotieren für Sensitivitätsanalyse (Technisch vs. Material)
  pivot_longer(
    cols = c(Techn_Nutzungsdauer_a, Material_Lebensdauer_a),
    names_to = "lebensdauer_typ",
    values_to = "lebensdauer_wert"
  ) %>%
  
  mutate(
    szenario = "Alle Szenarien", 
    kategorie = "Leitung",
    # Unterscheidung im Namen
    komponente = paste0(Leitungstyp, " (", 
                        if_else(lebensdauer_typ == "Techn_Nutzungsdauer_a", "Techn.", "Mat."), 
                        ")")
  ) %>%
  
  select(szenario, kategorie, komponente, lebensdauer = lebensdauer_wert)

# --- 2.2 Beläge aufbereiten (Unverändert) ---
df_sieger_belaege_ld <- df_sieger_belaege_roh %>%
  left_join(df_belaege_stammdaten %>% select(option, lebensdauer), by = "option") %>%
  select(szenario, kategorie = belagskategorie, komponente = option, lebensdauer)

# --- 2.3 Bäume aufbereiten (Unverändert) ---
df_sieger_baeume_ld <- df_sieger_baeume_roh %>%
  left_join(df_baeume_stammdaten %>% select(baumart, lebensdauer), by = "baumart") %>%
  select(szenario, kategorie = baumkategorie, komponente = baumart, lebensdauer)

```

## 3. Master-Tabelle erstellen
Ziel: Eine "Master-Tabelle" erstellen, die Jede Komponente für Jedes Szenario enthält.

```{r}
## 3. Master-Tabelle erstellen

# Ziel: Master-Tabelle mit Info, wer der "Sieger" (Rang 1) ist.

# 1. Liste der Szenarien
szenario_liste <- unique(df_sieger_belaege_ld$szenario)

# 2. Leitungen (Rang 0 = Boss)
df_leitungen_final <- df_leitungen %>%
  select(-szenario) %>% 
  crossing(szenario = szenario_liste) %>% 
  select(szenario, kategorie, komponente, lebensdauer) %>%
  mutate(rang = 0) # Leitungen haben immer Vorrang

# 3. Sieger Beläge und Bäume (Wir fügen den Rang hinzu)
# Wir gehen davon aus, dass die Input-CSVs sortiert sind (Platz 1 oben)
df_belaege_mit_rang <- df_sieger_belaege_ld %>%
  group_by(szenario) %>%
  mutate(rang = row_number()) %>% # Erstellt 1, 2, 3
  ungroup()

df_baeume_mit_rang <- df_sieger_baeume_ld %>%
  group_by(szenario) %>%
  mutate(rang = row_number()) %>%
  ungroup()

# 4. Zusammenfügen
df_master <- bind_rows(
  df_leitungen_final,
  df_belaege_mit_rang,
  df_baeume_mit_rang
)

```



```{r}
#| include: false
# --- PRÜFUNG BLOCK 3 ---
print("--- Check 1: Stimmt die Anzahl Zeilen? ---")
# Rechnung NEU:
# Leitungen: 10 Typen * 4 Szenarien = 40
# Beläge:     3 Typen * 4 Szenarien = 12
# Bäume:      3 Typen * 4 Szenarien = 12
# TOTAL:      40 + 12 + 12 = 64 Zeilen
nrow(df_master)

print("--- Check 2: Sind pro Szenario 3 Bäume da? ---")
df_master %>% 
  filter(szenario == "Szenario 0: Baseline (IST)", kategorie == "Grosskronige Arten") 
  # Hinweis: Die Kategorie heisst evtl. anders, je nach Daten. 
  # Besser: Wir zählen einfach pro Kategorie
  
df_master %>%
  filter(szenario == "Szenario 0: Baseline (IST)") %>%
  count(kategorie)

print("--- Check: Existiert die Spalte 'rang'? ---")
head(df_master)

```

## 4. Sanierungs-Events berechnen
Ziel: Den 100-Jahres-Zeitstrahl mit allen Sanierungs-Punkten berechnen.

```{r}
## 4. Sanierungs-Events berechnen

zeitstrahl_events <- df_master %>%
  mutate(sanierungs_jahr = map(lebensdauer, ~ seq(from = 0, to = 100, by = .x))) %>%
  unnest(sanierungs_jahr) %>%
  filter(sanierungs_jahr > 0, sanierungs_jahr <= 100) %>%
  
  # WICHTIG: 'rang' muss hier im select stehen!
  select(szenario, kategorie, komponente, lebensdauer, sanierungs_jahr, rang) %>%
  
  arrange(szenario, komponente, sanierungs_jahr)

write_csv2(zeitstrahl_events, "02_export/tables/zeitstrahl_events_100a.csv")
```



```{r}
#| include: false
# --- PRÜFUNG BLOCK 4 ---
print("--- Check 1: Anzahl Events insgesamt ---")
nrow(zeitstrahl_events) 

print("--- Check 2: Beispiel Selbstheilender Asphalt (S0) ---")
# Der hält ca. 42-45 Jahre. Wir erwarten Eingriffe bei ca. 45 und 90.
zeitstrahl_events %>%
  filter(szenario == "Szenario 0: Baseline (IST)", grepl("Asphalt", komponente))

print("--- Check 3: Gibt es noch Jahr 0? (Sollte 0 Zeilen sein) ---")
zeitstrahl_events %>% filter(sanierungs_jahr == 0)

```

## 5. Finale Synthese: Zeitstrahl-Visualisierung
Ziel: Vergleich der Sanierungs-Szenarien zur Beantwortung von H1 & H2.

```{r}
## 5. Finale Synthese: Zeitstrahl-Visualisierung (Getrennt)

# Ziel: Vergleich der Sanierungs-Szenarien (Technisch vs. Material getrennt).

# 1. Datensätze trennen
# Wir behalten IMMER alle Bäume/Beläge, aber filtern die Leitungen
events_techn <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Techn\\.\\)", komponente))

events_mat <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Mat\\.\\)", komponente))

# 2. Plot-Funktion (angepasst für Split)
plot_zeitstrahl_split <- function(data, szenario_titel, filename_suffix) {
  
  # Filtern der relevanten Szenarien (S0 vs. Vergleich)
  data_plot <- data %>%
    filter(szenario %in% c("Szenario 0: Baseline (IST)", szenario_titel)) %>%
    mutate(Hauptgruppe = case_when(
      kategorie == "Leitung" ~ "Leitungen",
      grepl("Arten", kategorie) ~ "Bäume",
      TRUE ~ "Beläge"
    ))
  
  p <- ggplot(data_plot, aes(x = sanierungs_jahr, 
                             y = fct_reorder(komponente, lebensdauer), 
                             color = Hauptgruppe)) +
    geom_vline(xintercept = seq(0, 100, 10), color = "grey92") +
    geom_point(size = 3.5, alpha = 0.9) +
    facet_wrap(~szenario, ncol = 1, scales = "free_y") +
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    labs(title = NULL, x = "Jahr", y = NULL, color = NULL) +
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      strip.background = element_rect(fill = "grey95", color = NA),
      strip.text = element_text(face = "bold", hjust = 0),
      axis.text = element_text(color = "black")
    )
  
   ggsave(paste0("02_export/plots/Zeitstrahl_", filename_suffix, ".png"), 
         plot = p, width = 10, height = 10, dpi = 300)
  print(p)
}

# --- PLOTS GENERIEREN (TECHNISCH) ---
plot_zeitstrahl_split(events_techn, "Szenario 1: Forschungsfokus", "Techn_S0_vs_S1")
plot_zeitstrahl_split(events_techn, "Szenario 2: Radikale Vermeidung", "Techn_S0_vs_S2")
plot_zeitstrahl_split(events_techn, "Szenario 3: Radikaler Lebenszyklus", "Techn_S0_vs_S3")

# --- PLOTS GENERIEREN (MATERIAL) ---
plot_zeitstrahl_split(events_mat, "Szenario 1: Forschungsfokus", "Mat_S0_vs_S1")
plot_zeitstrahl_split(events_mat, "Szenario 2: Radikale Vermeidung", "Mat_S0_vs_S2")
plot_zeitstrahl_split(events_mat, "Szenario 3: Radikaler Lebenszyklus", "Mat_S0_vs_S3")
```

## 6. Optimierter Zeitstrahl
Ziel: Lösungsdarstellung für so wenige Sanierungszyklen wie möglich

```{r}
## 6. Optimierung: Hierarchische Bündelung (Leitungen > Sieger-Belag)

optimize_events_hierarchisch <- function(data, anchors_tiefbau, toleranz = 15) {
  
  # Schritt A: Wir identifizieren die Jahre, in denen der Sieger-Belag (Rang 1) saniert wird.
  # KORREKTUR: Wir filtern alles, was NICHT Leitung und NICHT Baum ist.
  surface_anchors_df <- data %>%
    filter(!str_detect(kategorie, "Leitung|Arten"), rang == 1) %>%
    select(szenario, anker_belag = sanierungs_jahr)
  
  # Wir fügen diese Info an den Hauptdatensatz an
  data_joined <- data %>%
    left_join(surface_anchors_df, by = "szenario", relationship = "many-to-many")
  
  # Schritt B: Die Optimierung
  data_joined %>%
    mutate(
      # 1. Wer ist fix? NUR die tiefen Leitungen
      is_fix_tiefbau = str_detect(komponente, "Abwasser|Regenwasser"),
      
      jahr_optimiert = case_when(
        # Fall A: Tiefe Leitungen bleiben fix
        is_fix_tiefbau ~ sanierungs_jahr,
        
        # Fall B: Alle prüfen zuerst gegen TIEFBAU-ANKER
        TRUE ~ {
          # Suche Tiefbau-Anker in Toleranz
          closest_tief <- map_dbl(sanierungs_jahr, ~ {
            diffs <- .x - anchors_tiefbau
            valid <- anchors_tiefbau[abs(diffs) <= toleranz]
            if(length(valid) > 0) valid[1] else NA
          })
          
          # Fall C: Wenn kein Tiefbau-Anker, prüfe gegen BELAGS-ANKER
          # Aber nur für Beläge (nicht für Bäume oder Leitungen)
          is_belag = !str_detect(kategorie, "Leitung|Arten")
          
          closest_belag <- if_else(is.na(closest_tief) & is_belag,
             map2_dbl(sanierungs_jahr, anker_belag, ~ {
               # Ist der aktuelle Punkt nah am Sieger-Belag-Jahr?
               if(abs(.x - .y) <= 10) .y else NA # Kleinere Toleranz (10J) für Oberfläche
             }),
             NA_real_)
          
          # ENTSCHEIDUNG:
          coalesce(closest_tief, closest_belag, sanierungs_jahr)
        }
      ),
      
      wurde_verschoben = sanierungs_jahr != jahr_optimiert
    ) %>%
    # Deduplizieren
    group_by(szenario, kategorie, komponente, lebensdauer, sanierungs_jahr) %>%
    slice(1) %>%
    ungroup()
}

# --- ANWENDUNG ---

# 1. Technisch (Anker 60, 80)
df_opt_techn <- optimize_events_hierarchisch(events_techn, anchors_tiefbau = c(60, 80))

# 2. Material (Anker 70, 100)
df_opt_mat   <- optimize_events_hierarchisch(events_mat, anchors_tiefbau = c(70, 100))
```


```{r}
#| include: false
# Speichern
write_csv2(df_opt_techn, "02_export/tables/zeitstrahl_optimiert_techn.csv")
write_csv2(df_opt_mat, "02_export/tables/zeitstrahl_optimiert_mat.csv")

print("Hierarchische Optimierung abgeschlossen.")

```

## 7. Visualisierung

```{r}
## 7. Visualisierung: Optimierter Zeitstrahl (Scientific Style)

plot_opt_split <- function(data, szenario_name, anchors, filename) {
  
  data_plot <- data %>% filter(szenario == szenario_name)
  
  p <- ggplot(data_plot, aes(y = fct_reorder(komponente, lebensdauer))) +
    
    # 1. Anker-Linien (Die "Magnete")
    geom_vline(xintercept = anchors, color = "firebrick", linetype = "dashed", alpha = 0.6) +
    
    # 2. Pfeile (Verschiebung)
    geom_segment(aes(x = sanierungs_jahr, xend = jahr_optimiert, yend = komponente),
                 arrow = arrow(length = unit(0.15, "cm"), type = "closed"), 
                 color = "grey60",
                 data = filter(data_plot, wurde_verschoben)) +
    
    # 3. Ghost-Punkte (Original-Zeitpunkt)
    geom_point(aes(x = sanierungs_jahr), 
               shape = 21,          # Kreis mit Rand
               color = "grey30",    # Rand dunkelgrau
               fill = "white",      # Innen weiss
               size = 2.5, 
               alpha = 0.7) +
    
    # 4. Optimierte Punkte (Finaler Zeitpunkt)
    geom_point(aes(x = jahr_optimiert, 
                   color = case_when(kategorie == "Leitung" ~ "Leitungen",
                                     grepl("Arten", kategorie) ~ "Bäume",
                                     TRUE ~ "Beläge")), 
               size = 3.5) +
    
    # Skalen & Farben
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    
    # Clean Labels
    labs(title = NULL, 
         subtitle = paste(szenario_name), 
         x = "Jahr (Pfeil zeigt Bündelung)", y = NULL, color = NULL) +
    
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      axis.text = element_text(color = "black")
    )
 ggsave(filename, plot = p, width = 10, height = 7, dpi = 300)
  print(p)

}
```


```{r}
#| include: false

# --- PLOTS TECHNISCH (Anker 60/80) ---
plot_opt_split(df_opt_techn, "Szenario 0: Baseline (IST)", c(60, 80), "02_export/plots/Optimierung_Techn_S0.png")
plot_opt_split(df_opt_techn, "Szenario 1: Forschungsfokus", c(60, 80), "02_export/plots/Optimierung_Techn_S1.png")
plot_opt_split(df_opt_techn, "Szenario 2: Radikale Vermeidung", c(60, 80), "02_export/plots/Optimierung_Techn_S2.png")
plot_opt_split(df_opt_techn, "Szenario 3: Radikaler Lebenszyklus", c(60, 80), "02_export/plots/Optimierung_Techn_S3.png")

# --- PLOTS MATERIAL (Anker 70/100) ---
plot_opt_split(df_opt_mat, "Szenario 0: Baseline (IST)", c(70, 100), "02_export/plots/Optimierung_Mat_S0.png")
plot_opt_split(df_opt_mat, "Szenario 1: Forschungsfokus", c(70, 100), "02_export/plots/Optimierung_Mat_S1.png")
plot_opt_split(df_opt_mat, "Szenario 2: Radikale Vermeidung", c(70, 100), "02_export/plots/Optimierung_Mat_S2.png")
plot_opt_split(df_opt_mat, "Szenario 3: Radikaler Lebenszyklus", c(70, 100), "02_export/plots/Optimierung_Mat_S3.png")
```






