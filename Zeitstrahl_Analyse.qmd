---
title: "Zeitstrahl_Analyse"
author: "Sarah Pfeiffer"
date: today
format: 
    html:
        toc: true
        code-fold: false

---
# Zeitstrahl-Analyse
Ziel: 

## Libraries Laden

```{r}
library(tidyverse)
library(readr)
library(ggplot2)
library(forcats) # Für fct_rev()
library(tidyr)   # Für complete()
library(purrr)   # Für map()

```

## 1. Daten importieren
Ziel: Lädt alle 5 CSV-Dateien, die für diese Analyse notwendig sind

```{r}
# --- A. Input 1: Die "Sieger" (Ergebnis aus MCA) ---
df_sieger_belaege_roh <- read_csv2("02_export/tables/mca_top3_belaege_pro_szenario.csv")
df_sieger_baeume_roh  <- read_csv2("02_export/tables/mca_top3_baeume_pro_szenario.csv")

# --- B. Input 2: Die "Stammdaten" (um Lebensdauer zu holen) ---
df_belaege_stammdaten <- read_delim("01_data_input/Belaege_tidy.csv", delim = ";")
df_baeume_stammdaten  <- read_delim("01_data_input/Baeume_tidy.csv", delim = ";")

# --- C. Input 3: Die "Konstanten" (Leitungen) ---
df_leitungen_roh <- read_csv2("01_data_input/Leitungen_IST.csv")

```


```{r}
#| include: false
# --- PRÜFUNG BLOCK 1 ---
print("--- Check: Wurden die Sieger geladen? ---")
head(df_sieger_belaege_roh, 6)

print("--- Check: Sind die Leitungen da? ---")
# Hier müssen Spalten wie 'Leitungstyp' und 'Techn_Nutzungsdauer_a' (oder ähnlich) stehen
colnames(df_leitungen_roh)

```

## 2. Daten Aufbereiten
Ziel: Alle Komponenten (Leitungen, Beläge, Bäume) in ein einheitliches Format bringen (szenario, kategorie, komponente, lebensdauer).

```{r}

## 2. Daten harmonisieren

# --- 2.1 Leitungen aufbereiten (Nur Graben = Konflikt) ---
df_leitungen <- df_leitungen_roh %>%
  # WICHTIG: Wir filtern streng auf "Graben".
  # "Kabelzug" ist kein Konflikt für Bäume/Beläge und wird ignoriert.
  filter(Eingriffs_Typ == "Graben") %>%
  
  # Pivotieren für Sensitivitätsanalyse (Technisch vs. Material)
  pivot_longer(
    cols = c(Techn_Nutzungsdauer_a, Material_Lebensdauer_a),
    names_to = "lebensdauer_typ",
    values_to = "lebensdauer_wert"
  ) %>%
  
  mutate(
    szenario = "Alle Szenarien", 
    kategorie = "Leitung",
    # Unterscheidung im Namen
    komponente = paste0(Leitungstyp, " (", 
                        if_else(lebensdauer_typ == "Techn_Nutzungsdauer_a", "Techn.", "Mat."), 
                        ")")
  ) %>%
  
  select(szenario, kategorie, komponente, lebensdauer = lebensdauer_wert)

# --- 2.2 Beläge aufbereiten (Unverändert) ---
df_sieger_belaege_ld <- df_sieger_belaege_roh %>%
  left_join(df_belaege_stammdaten %>% select(option, lebensdauer), by = "option") %>%
  select(szenario, kategorie = belagskategorie, komponente = option, lebensdauer)

# --- 2.3 Bäume aufbereiten (Unverändert) ---
df_sieger_baeume_ld <- df_sieger_baeume_roh %>%
  left_join(df_baeume_stammdaten %>% select(baumart, lebensdauer), by = "baumart") %>%
  select(szenario, kategorie = baumkategorie, komponente = baumart, lebensdauer)

```

## 3. Master-Tabelle erstellen
Ziel: Eine "Master-Tabelle" erstellen, die Jede Komponente für Jedes Szenario enthält.

```{r}
## 3. Master-Tabelle erstellen

# Ziel: Master-Tabelle mit Info, wer der "Sieger" (Rang 1) ist.

# 1. Liste der Szenarien
szenario_liste <- unique(df_sieger_belaege_ld$szenario)

# 2. Leitungen (Rang 0 = Boss)
df_leitungen_final <- df_leitungen %>%
  select(-szenario) %>% 
  crossing(szenario = szenario_liste) %>% 
  select(szenario, kategorie, komponente, lebensdauer) %>%
  mutate(rang = 0) # Leitungen haben immer Vorrang

# 3. Sieger Beläge und Bäume (Wir fügen den Rang hinzu)
# Wir gehen davon aus, dass die Input-CSVs sortiert sind (Platz 1 oben)
df_belaege_mit_rang <- df_sieger_belaege_ld %>%
  group_by(szenario) %>%
  mutate(rang = row_number()) %>% # Erstellt 1, 2, 3
  ungroup()

df_baeume_mit_rang <- df_sieger_baeume_ld %>%
  group_by(szenario) %>%
  mutate(rang = row_number()) %>%
  ungroup()

# 4. Zusammenfügen
df_master <- bind_rows(
  df_leitungen_final,
  df_belaege_mit_rang,
  df_baeume_mit_rang
)

```



```{r}
#| include: false
# --- PRÜFUNG BLOCK 3 ---
print("--- Check 1: Stimmt die Anzahl Zeilen? ---")
# Rechnung NEU:
# Leitungen: 10 Typen * 4 Szenarien = 40
# Beläge:     3 Typen * 4 Szenarien = 12
# Bäume:      3 Typen * 4 Szenarien = 12
# TOTAL:      40 + 12 + 12 = 64 Zeilen
nrow(df_master)

print("--- Check 2: Sind pro Szenario 3 Bäume da? ---")
df_master %>% 
  filter(szenario == "Szenario 0: Baseline (IST)", kategorie == "Grosskronige Arten") 
  # Hinweis: Die Kategorie heisst evtl. anders, je nach Daten. 
  # Besser: Wir zählen einfach pro Kategorie
  
df_master %>%
  filter(szenario == "Szenario 0: Baseline (IST)") %>%
  count(kategorie)

print("--- Check: Existiert die Spalte 'rang'? ---")
head(df_master)

```

## 4. Sanierungs-Events berechnen
Ziel: Den 100-Jahres-Zeitstrahl mit allen Sanierungs-Punkten berechnen.

```{r}
## 4. Sanierungs-Events berechnen

zeitstrahl_events <- df_master %>%
  mutate(sanierungs_jahr = map(lebensdauer, ~ seq(from = 0, to = 100, by = .x))) %>%
  unnest(sanierungs_jahr) %>%
  filter(sanierungs_jahr > 0, sanierungs_jahr <= 100) %>%
  
  # WICHTIG: 'rang' muss hier im select stehen!
  select(szenario, kategorie, komponente, lebensdauer, sanierungs_jahr, rang) %>%
  
  arrange(szenario, komponente, sanierungs_jahr)

write_csv2(zeitstrahl_events, "02_export/tables/zeitstrahl_events_100a.csv")
```



```{r}
#| include: false
# --- PRÜFUNG BLOCK 4 ---
print("--- Check 1: Anzahl Events insgesamt ---")
nrow(zeitstrahl_events) 

print("--- Check 2: Beispiel Selbstheilender Asphalt (S0) ---")
# Der hält ca. 42-45 Jahre. Wir erwarten Eingriffe bei ca. 45 und 90.
zeitstrahl_events %>%
  filter(szenario == "Szenario 0: Baseline (IST)", grepl("Asphalt", komponente))

print("--- Check 3: Gibt es noch Jahr 0? (Sollte 0 Zeilen sein) ---")
zeitstrahl_events %>% filter(sanierungs_jahr == 0)

```

## 5. Finale Synthese: Zeitstrahl-Visualisierung
Ziel: Vergleich der Sanierungs-Szenarien zur Beantwortung von H1 & H2.

```{r}
## 5. Finale Synthese: Zeitstrahl-Visualisierung (Getrennt)

# Ziel: Vergleich der Sanierungs-Szenarien (Technisch vs. Material getrennt).

# 1. Datensätze trennen
# Wir behalten IMMER alle Bäume/Beläge, aber filtern die Leitungen
events_techn <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Techn\\.\\)", komponente))

events_mat <- zeitstrahl_events %>%
  filter(kategorie != "Leitung" | grepl("\\(Mat\\.\\)", komponente))

# 2. Plot-Funktion (angepasst für Split)
plot_zeitstrahl_split <- function(data, szenario_titel, filename_suffix) {
  
  # Filtern der relevanten Szenarien (S0 vs. Vergleich)
  data_plot <- data %>%
    filter(szenario %in% c("Szenario 0: Baseline (IST)", szenario_titel)) %>%
    mutate(Hauptgruppe = case_when(
      kategorie == "Leitung" ~ "Leitungen",
      grepl("Arten", kategorie) ~ "Bäume",
      TRUE ~ "Beläge"
    ))
  
  p <- ggplot(data_plot, aes(x = sanierungs_jahr, 
                             y = fct_reorder(komponente, lebensdauer), 
                             color = Hauptgruppe)) +
    geom_vline(xintercept = seq(0, 100, 10), color = "grey92") +
    geom_point(size = 3.5, alpha = 0.9) +
    facet_wrap(~szenario, ncol = 1, scales = "free_y") +
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    labs(title = NULL, x = "Jahr", y = NULL, color = NULL) +
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      strip.background = element_rect(fill = "grey95", color = NA),
      strip.text = element_text(face = "bold", hjust = 0),
      axis.text = element_text(color = "black")
    )
  
   ggsave(paste0("02_export/plots/Zeitstrahl_", filename_suffix, ".png"), 
         plot = p, width = 10, height = 10, dpi = 300)
  print(p)
}

# --- PLOTS GENERIEREN (TECHNISCH) ---
plot_zeitstrahl_split(events_techn, "Szenario 1: Forschungsfokus", "Techn_S0_vs_S1")
plot_zeitstrahl_split(events_techn, "Szenario 2: Radikale Vermeidung", "Techn_S0_vs_S2")
plot_zeitstrahl_split(events_techn, "Szenario 3: Radikaler Lebenszyklus", "Techn_S0_vs_S3")

# --- PLOTS GENERIEREN (MATERIAL) ---
plot_zeitstrahl_split(events_mat, "Szenario 1: Forschungsfokus", "Mat_S0_vs_S1")
plot_zeitstrahl_split(events_mat, "Szenario 2: Radikale Vermeidung", "Mat_S0_vs_S2")
plot_zeitstrahl_split(events_mat, "Szenario 3: Radikaler Lebenszyklus", "Mat_S0_vs_S3")
```

## 6. Optimierter Zeitstrahl
Ziel: Lösungsdarstellung für so wenige Sanierungszyklen wie möglich

```{r}
optimize_events_final <- function(data, anchors_tiefbau, tol_tiefbau = 15, tol_oberflaeche = 10) {
  
  # --- HILFSFUNKTION: Berechnung einer einzelnen Komponente ---
  process_single_component <- function(comp_df, anchors_tief, anchors_surface = NULL) {
    # Sortieren nach Jahr
    comp_df <- comp_df %>% arrange(sanierungs_jahr)
    
    # Metadaten
    is_fix_pipe <- str_detect(comp_df$komponente[1], "Abwasser|Regenwasser")
    is_belag    <- !str_detect(comp_df$kategorie[1], "Leitung|Arten")
    lebensdauer <- comp_df$lebensdauer[1]
    
    # Ergebnis-Vektoren initialisieren
    theo_vec <- numeric(nrow(comp_df))
    opt_vec  <- numeric(nrow(comp_df))
    
    last_optimized_year <- 0
    
    for(i in 1:nrow(comp_df)) {
      # 1. THEORETISCHER BEDARF (Weisser Punkt)
      if (is_fix_pipe) {
        # Fixe Leitungen behalten ihr Jahr
        bedarf <- comp_df$sanierungs_jahr[i]
      } else {
        # Dynamisch: Letzter Blauer Punkt + Lebensdauer
        bedarf <- last_optimized_year + lebensdauer
      }
      
      # 2. OPTIMIERUNG (Blauer Punkt)
      if (is_fix_pipe) {
        opt <- bedarf
      } else {
        opt <- NA_real_
        
        # A) Check gegen Tiefbau (Stufe 1)
        # Toleranzwahl: Beläge strikt 10, Rest 15
        tol_val <- if(is_belag) tol_oberflaeche else tol_tiefbau
        
        diffs_t <- bedarf - anchors_tief
        matches_t <- anchors_tief[abs(diffs_t) <= tol_val]
        
        if(length(matches_t) > 0) {
          # Nimm den nächsten
          opt <- matches_t[which.min(abs(bedarf - matches_t))]
        }
        
        # B) Check gegen Oberfläche (Stufe 2) - NUR wenn Stufe 1 leer UND wir Surface-Anker haben
        if(is.na(opt) && is_belag && !is.null(anchors_surface)) {
          diffs_s <- bedarf - anchors_surface
          matches_s <- anchors_surface[abs(diffs_s) <= tol_oberflaeche] # Strikt 10
          
          if(length(matches_s) > 0) {
            opt <- matches_s[which.min(abs(bedarf - matches_s))]
          }
        }
        
        # C) Fallback: Keine Verschiebung
        if(is.na(opt)) {
          opt <- bedarf
        }
      }
      
      # Speichern für nächste Iteration
      theo_vec[i] <- bedarf
      opt_vec[i]  <- opt
      last_optimized_year <- opt
    }
    
    comp_df$theoretischer_bedarf <- theo_vec
    comp_df$jahr_optimiert       <- opt_vec
    return(comp_df)
  }
  
  # --- HAUPTABLAUF ---
  
  # Schritt 1: Trennung der Daten
  # Gruppe A: Treiber (Leitungen, Bäume, Beläge Rang 1)
  drivers <- data %>% 
    filter(str_detect(kategorie, "Leitung|Arten") | rang == 1)
  
  # Gruppe B: Follower (Beläge Rang 2 & 3)
  followers <- data %>% 
    filter(!str_detect(kategorie, "Leitung|Arten") & rang > 1)
  
  # Schritt 2: Treiber berechnen (Phase 1)
  # Hier gibt es noch keine Surface-Anker, nur Tiefbau-Anker
  drivers_processed <- drivers %>%
    group_by(szenario, komponente) %>%
    group_split() %>%
    map_dfr(~ process_single_component(.x, anchors_tiefbau, anchors_surface = NULL))
  
  # Schritt 3: Neue Surface-Anker aus den optimierten Treibern extrahieren
  # Wir nehmen die optimierten Jahre der Rang-1 Beläge
  new_surface_anchors_list <- drivers_processed %>%
    filter(!str_detect(kategorie, "Leitung|Arten"), rang == 1) %>%
    group_by(szenario) %>%
    summarise(anchors = list(unique(jahr_optimiert))) %>%
    deframe()
  
  # Schritt 4: Follower berechnen (Phase 2)
  # Diese nutzen Tiefbau-Anker UND die eben berechneten Surface-Anker
  if(nrow(followers) > 0) {
    followers_processed <- followers %>%
      group_by(szenario, komponente) %>%
      group_split() %>%
      map_dfr(function(df) {
        sz <- df$szenario[1]
        surf_anchors <- if(sz %in% names(new_surface_anchors_list)) new_surface_anchors_list[[sz]] else NULL
        process_single_component(df, anchors_tiefbau, anchors_surface = surf_anchors)
      })
    
    # Zusammenfügen
    result <- bind_rows(drivers_processed, followers_processed)
  } else {
    result <- drivers_processed
  }
  
  # Schritt 5: Finalisierung für Grafik
  result <- result %>%
    mutate(
      # Überschreibe das Original-Jahr für den Plot (Weisser Punkt)
      sanierungs_jahr = theoretischer_bedarf,
      wurde_verschoben = abs(sanierungs_jahr - jahr_optimiert) > 0.1,
      differenz = jahr_optimiert - sanierungs_jahr
    )
  
  return(result)
}

# --- TEST-LAUF & DEBUGGING ---

# Führe die Funktion aus
df_opt_techn <- optimize_events_final(events_techn, anchors_tiefbau = c(60, 80))

# DEBUG CHECK: Schauen wir uns EXAKT die kritischen Werte an
debug_view <- df_opt_techn %>%
  filter(szenario == "Szenario 0: Baseline (IST)", 
         str_detect(komponente, "Naturstein|Betonpflaster")) %>%
  select(komponente, rang, theoretischer_bedarf, jahr_optimiert, differenz) %>%
  arrange(komponente, theoretischer_bedarf)

print("--- DEBUGGING ERGEBNISSE ---")
print(debug_view)
# --- ANWENDUNG ---

# 1. Technisch (Anker 60, 80)
# WICHTIG: Hier 'optimize_events_final' nutzen!
df_opt_techn <- optimize_events_final(events_techn, anchors_tiefbau = c(60, 80))

# 2. Material (Anker 70, 100)
df_opt_mat   <- optimize_events_final(events_mat, anchors_tiefbau = c(70, 100))

# --- DEBUGGING AUSGABE ---
# Das hier zeigt dir den Beweis, dass es geklappt hat
debug_view <- df_opt_techn %>%
  filter(szenario == "Szenario 0: Baseline (IST)", 
         str_detect(komponente, "Naturstein|Betonpflaster")) %>%
  select(komponente, rang, theoretischer_bedarf, jahr_optimiert, differenz) %>%
  arrange(komponente, theoretischer_bedarf)

print("--- ERGEBNIS CHECK (Sollte 77.5 -> 80 und 87.5 -> 80 zeigen) ---")
print(debug_view)
```


```{r}
#| include: false
# Speichern
write_csv2(df_opt_techn, "02_export/tables/zeitstrahl_optimiert_techn.csv")
write_csv2(df_opt_mat, "02_export/tables/zeitstrahl_optimiert_mat.csv")

print("Hierarchische Optimierung abgeschlossen.")

```

## 7. Visualisierung

```{r}
## 7. Visualisierung: Optimierter Zeitstrahl (Scientific Style)

plot_opt_split <- function(data, szenario_name, anchors, filename) {
  
  data_plot <- data %>% filter(szenario == szenario_name)
  
  p <- ggplot(data_plot, aes(y = fct_reorder(komponente, lebensdauer))) +
    
    # 1. Anker-Linien (Die "Magnete")
    geom_vline(xintercept = anchors, color = "firebrick", linetype = "dashed", alpha = 0.6) +
    
    # 2. Pfeile (Verschiebung)
    geom_segment(aes(x = sanierungs_jahr, xend = jahr_optimiert, yend = komponente),
                 arrow = arrow(length = unit(0.15, "cm"), type = "closed"), 
                 color = "grey60",
                 data = filter(data_plot, wurde_verschoben)) +
    
    # 3. Ghost-Punkte (Original-Zeitpunkt)
    geom_point(aes(x = sanierungs_jahr), 
               shape = 21,          # Kreis mit Rand
               color = "grey30",    # Rand dunkelgrau
               fill = "white",      # Innen weiss
               size = 2.5, 
               alpha = 0.7) +
    
    # 4. Optimierte Punkte (Finaler Zeitpunkt)
    geom_point(aes(x = jahr_optimiert, 
                   color = case_when(kategorie == "Leitung" ~ "Leitungen",
                                     grepl("Arten", kategorie) ~ "Bäume",
                                     TRUE ~ "Beläge")), 
               size = 3.5) +
    
    # Skalen & Farben
    scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 105)) +
    scale_color_manual(values = c("Leitungen" = "black", 
                                  "Bäume" = "#2ca02c", 
                                  "Beläge" = "#084594")) +
    
    # Clean Labels
    labs(title = NULL, 
         subtitle = paste(szenario_name), 
         x = "Jahr (Pfeil zeigt Bündelung)", y = NULL, color = NULL) +
    
    theme_classic(base_size = 11) +
    theme(
      legend.position = "bottom",
      panel.grid.major.y = element_line(color = "grey90", linewidth = 0.2),
      panel.grid.major.x = element_blank(),
      axis.text = element_text(color = "black")
    )
 ggsave(filename, plot = p, width = 10, height = 7, dpi = 300)
  print(p)

}

# --- PLOTS TECHNISCH (Anker 60/80) ---
plot_opt_split(df_opt_techn, "Szenario 0: Baseline (IST)", c(60, 80), "02_export/plots/Optimierung_Techn_S0.png")
plot_opt_split(df_opt_techn, "Szenario 1: Forschungsfokus", c(60, 80), "02_export/plots/Optimierung_Techn_S1.png")
plot_opt_split(df_opt_techn, "Szenario 2: Radikale Vermeidung", c(60, 80), "02_export/plots/Optimierung_Techn_S2.png")
plot_opt_split(df_opt_techn, "Szenario 3: Radikaler Lebenszyklus", c(60, 80), "02_export/plots/Optimierung_Techn_S3.png")

# --- PLOTS MATERIAL (Anker 70/100) ---
plot_opt_split(df_opt_mat, "Szenario 0: Baseline (IST)", c(70, 100), "02_export/plots/Optimierung_Mat_S0.png")
plot_opt_split(df_opt_mat, "Szenario 1: Forschungsfokus", c(70, 100), "02_export/plots/Optimierung_Mat_S1.png")
plot_opt_split(df_opt_mat, "Szenario 2: Radikale Vermeidung", c(70, 100), "02_export/plots/Optimierung_Mat_S2.png")
plot_opt_split(df_opt_mat, "Szenario 3: Radikaler Lebenszyklus", c(70, 100), "02_export/plots/Optimierung_Mat_S3.png")
```






